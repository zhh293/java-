package algthrom;

public class 一致性哈希算法 {
    //首先我们必须要讲解一下一致性哈希算法存在的价值和解决的问题是什么

//    一致性哈希算法：原理、作用、机制与应用场景
//    一致性哈希算法是分布式系统中解决数据分片、节点负载均衡的核心算法，它的诞生是为了弥补传统哈希取模法在节点动态增减时的缺陷。本文会用钟表环形类比+分步拆解的方式，把抽象的算法讲得通俗易懂，同时结合分布式缓存的实际场景说明其价值。
//    一、 先搞懂：为什么需要一致性哈希？
//    要理解一致性哈希的作用，先看传统哈希取模法的痛点。
//            1.  传统哈希取模的逻辑
//    假设我们有一个分布式缓存系统，有 N 个缓存节点，要将数据 Key 映射到某个节点，传统做法是：节点索引=hash(Key) % N比如：
//
//    哈希函数计算 key1 的值为 12345
//    节点数 N=3
//    节点索引 = 12345 % 3 = 0 → 数据存到节点 0
//
//            2.  传统方法的致命缺陷
//    当分布式系统需要动态扩容 / 缩容（比如节点故障下线、新增节点分担压力）时，N 会变化，此时几乎所有数据的映射关系都会失效，导致：
//
//    大量缓存失效：客户端请求会穿透缓存直接打在数据库上，引发缓存雪崩风险
//    海量数据迁移：所有数据需要重新计算映射关系并迁移，消耗大量网络和服务器资源
//
//    举个例子：
//
//    初始 N=3，数据 key1-key100 均匀分布在 3 个节点
//    新增 1 个节点，N=4，此时 key1 的映射结果从 12345%3=0 变成 12345%4=1
//    结果：100% 的数据都需要重新映射和迁移
//
//    而一致性哈希的核心目标，就是解决节点动态变化时的数据映射稳定性问题。










//
//    二、 一致性哈希的核心原理
//    一致性哈希的核心思想可以用一句话概括：
//
//    将「节点」和「数据」都映射到一个环形的哈希空间中，数据的归属规则是：顺时针找到离自己最近的节点。
//
//    我们用钟表环形类比来具象化这个过程：
//            1.  第一步：定义哈希空间（环形）
//    一致性哈希将哈希函数的输出值范围，映射成一个闭合的环形。
//
//    哈希函数（如 MD5、SHA-1）的输出是固定长度的整数（比如 MD5 输出 128 位整数，范围是 0∼2128−1）
//    我们把这个整数范围想象成一个钟表的刻度，从 0 开始，到 2128−1 结束后，又回到 0，形成一个环（类似钟表从 12 点回到 12 点）。
//
//            2.  第二步：节点映射到环上
//    将分布式系统中的每个节点（比如缓存服务器），通过相同的哈希函数计算其标识（如 IP 地址、主机名）的哈希值，然后将节点放置到环形哈希空间的对应位置。
//    比如：
//
//    节点 A 的 IP 是 192.168.1.101，哈希后的值是 1000 → 放在环上 1000 的位置
//    节点 B 的 IP 是 192.168.1.102，哈希后的值是 5000 → 放在环上 5000 的位置
//    节点 C 的 IP 是 192.168.1.103，哈希后的值是 9000 → 放在环上 9000 的位置
//
//3.  第三步：数据映射到环上
//    对每个需要存储的数据 Key，同样用相同的哈希函数计算其哈希值，将数据也放置到环上的对应位置。
//    然后遵循 **「顺时针找最近节点」的规则：从数据的哈希位置出发，沿着顺时针方向走，遇到的第一个节点 **，就是这个数据要存储的节点。
//    举例说明数据映射
//    假设：
//
//    数据 key1 哈希值是 2000 → 顺时针最近节点是 B（5000）
//    数据 key2 哈希值是 6000 → 顺时针最近节点是 C（9000）
//    数据 key3 哈希值是 10000 → 超过 C 的 9000，绕回环起点，最近节点是 A（1000）
//
//    环形映射示意图（简化版）：plaintext0 ────────────────────── 1000 (A) ─────────── 2000 (key1) ─────────── 5000 (B) ─────────── 6000 (key2) ─────────── 9000 (C) ─────────── 10000 (key3) ─────────── 2^128-1 ────┐
//            │                                                                                                                                                            │
//            └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
//
//    三、 一致性哈希的核心机制
//    一致性哈希的优势体现在节点动态增减时的数据迁移逻辑，同时为了解决数据倾斜问题，引入了虚拟节点机制。
//            1.  节点增减时的迁移规则（核心优势）
//    一致性哈希的最大价值是：节点扩容 / 缩容时，仅影响相邻节点的数据，全局数据迁移量极小。
//    场景 1：节点扩容（新增节点 D）
//    假设新增节点 D，其哈希值是 3000，放在环上 A(1000) 和 B(5000) 之间。此时只有哈希值在 1000~3000 之间的数据需要迁移：
//
//    原本属于 B 的 key1（哈希值 2000），现在顺时针最近节点变成 D
//    其他数据（key2、key3）的映射关系完全不变
//    数据迁移量仅为 (3000-1000)/(2^128)，远小于传统取模法的 100%
//
//    场景 2：节点缩容（节点 B 故障下线）
//    节点 B 下线后，原本属于 B 的数据（哈希值 5000~9000），会顺时针迁移到下一个节点 C
//
//    其他数据（key1、key3）的映射关系不变
//    仅迁移 B 节点的原有数据，不会影响全局
//
//2.  解决数据倾斜：虚拟节点机制
//    普通一致性哈希存在一个问题：如果节点数量少，哈希后的节点位置可能分布不均，导致数据负载倾斜。
//    比如 3 个节点恰好都集中在环的某一段，那么这段环上的数据会全部落在这几个节点上，其他节点空闲。
//    虚拟节点的核心思想
//    为每个物理节点创建多个虚拟节点，虚拟节点的数量可以配置（比如 100 个 / 物理节点）。
//
//    虚拟节点和物理节点是一对多的映射关系
//    数据先映射到虚拟节点，再由虚拟节点映射到对应的物理节点
//
//            虚拟节点的作用
//
//    分散节点位置：大量虚拟节点会均匀分布在环形哈希空间中，避免物理节点集中导致的负载不均
//    均衡数据负载：每个物理节点对应多个虚拟节点，相当于在环上占据多个位置，分摊更多数据
//
//            举例说明虚拟节点
//    假设物理节点 A 对应 3 个虚拟节点：A-1（哈希值 500）、A-2（哈希值 2500）、A-3（哈希值 8500）
//
//    数据映射到 A-1/A-2/A-3 时，最终都存储到物理节点 A
//    由于虚拟节点分布均匀，数据会被均匀分配到各个物理节点
//
//    四、 一致性哈希的核心作用
//    总结一致性哈希在分布式系统中的核心价值：
//
//    降低数据迁移成本：节点动态变化时，仅需迁移少量数据，避免缓存雪崩和服务器过载
//    提高缓存命中率：映射关系稳定，减少因节点变化导致的缓存失效
//    实现负载均衡：通过虚拟节点机制，确保数据均匀分布在所有节点上
//    增强系统容错性：单个节点故障时，仅影响该节点的相邻数据，不中断全局服务
//
//    五、 一致性哈希的典型应用场景
//    一致性哈希是分布式系统的基础算法，几乎所有需要数据分片、节点负载均衡的场景都有它的身影。
//            1.  分布式缓存（最核心场景）
//    这是一致性哈希最经典的应用，比如 Redis Cluster、Memcached 集群。
//
//    Redis Cluster 采用哈希槽（本质是一致性哈希的变种），将 16384 个哈希槽分布在不同节点上
//    每个 Key 通过 CRC16(Key) % 16384 计算哈希槽，再映射到对应节点
//    节点扩容 / 缩容时，仅迁移部分哈希槽的数据，保证集群稳定性
//
//2.  负载均衡
//    在反向代理和负载均衡场景中，一致性哈希可以实现会话保持和请求均匀分发。
//
//    比如 Nginx 的 ip_hash 模块的进阶版（基于一致性哈希）
//    将客户端 IP 映射到环上，请求会转发到顺时针最近的后端服务器
//    优势：客户端 IP 不变时，请求会一直转发到同一台服务器，实现会话粘性；后端服务器上下线时，仅少量客户端请求需要切换服务器
//
//3.  分布式存储系统
//    在分布式文件存储、对象存储系统中，一致性哈希用于数据分片存储。
//
//    比如 Ceph 分布式存储、GlusterFS
//    将文件 / 对象的 ID 映射到环上，存储到对应的存储节点
//    支持动态扩容：新增存储节点时，仅迁移部分数据，不影响整体服务
//
//4.  分布式数据库分片
//    在分库分表场景中，一致性哈希可以作为分片算法的一种选择。
//
//    比如将用户 ID 映射到环上，分配到不同的数据库节点
//    相比范围分片，一致性哈希的优势是扩容时数据迁移量小；相比哈希取模，优势是节点数量灵活变化
//
//    六、 一致性哈希的优缺点总结
//            优点
//    优点说明低迁移成本节点增减时仅影响相邻节点，数据迁移量极小高稳定性映射关系稳定，缓存命中率高，避免缓存雪崩扩展性强支持节点动态扩容 / 缩容，无需停机维护负载均衡结合虚拟节点机制，可实现数据均匀分布
//            缺点
//    缺点说明实现复杂相比传统哈希取模，需要维护环形哈希空间和虚拟节点映射哈希函数依赖哈希函数的均匀性直接影响数据分布，需选择高质量哈希函数（如 MD5、SHA-1）虚拟节点管理成本虚拟节点数量需要合理配置，过多会增加内存和计算开销
//    七、 一致性哈希 vs 传统哈希取模（对比表）
//    特性一致性哈希传统哈希取模节点增减影响范围仅影响相邻节点，迁移量小全局映射失效，迁移量 100%缓存命中率高（映射稳定）低（节点变化后大量缓存失效）扩展性支持动态扩容 / 缩容节点数量固定，扩容需重新计算负载均衡需结合虚拟节点，均衡性好节点数量固定时均衡，节点变化后失衡实现复杂度较高（需维护环形结构 + 虚拟节点）简单（仅需取模运算）


}
