package algthrom;

public class KMPDemo {
    /*二、先骂骂 “暴力匹配”：为什么需要 KMP？
    最直接的匹配方法是 “暴力匹配”（一个一个对），但效率极低，比如下面这个坑：
    假设主串是"AAAAAAB"（6 个 A+1 个 B），模式串是"AAAB"（3 个 A+1 个 B）：
    主串第 1-3 个 A，和模式串第 1-3 个 A 匹配，但主串第 4 个 A vs 模式串第 4 个 B—— 不匹配；
    暴力匹配会让 “主串指针回退到第 2 位”，重新比较主串第 2-4 个 A vs 模式串第 1-3 个 A……
    明明前面的 A 已经比过了，却要重复比较！这就像你找路时，走错一步就退回起点，太傻了。
    KMP 的核心改进：主串指针永远不回退！只调整模式串的指针，跳过重复比较的步骤。*/






/*    三、KMP 的 “核武器”：部分匹配表（前缀表）
    要做到 “主串不回退”，关键是搞懂 “模式串自己的规律”—— 也就是部分匹配表（也叫前缀表）。
    先明确两个基础概念（用 “不包含整个字符串” 来简化）：
    前缀：从开头开始，不包含最后一个字符的所有子串。比如 “ABCD” 的前缀是 “A、AB、ABC”；
    后缀：从结尾开始，不包含第一个字符的所有子串。比如 “ABCD” 的后缀是 “BCD、CD、D”。
    部分匹配表的核心：对模式串的每个子串，找 “前缀和后缀中最长的相同子串的长度”，这个长度就是 “部分匹配值”。
    举个例子：算模式串 “ABCDABD” 的部分匹配表
    模式串是A B C D A B D（共 7 个字符，索引 0-6），我们逐个算每个子串的 “部分匹配值”：
    模式串子串	前缀（不包含最后 1 个）	后缀（不包含第 1 个）	最长相同子串	部分匹配值
    A（索引 0）	无（只有 1 个字符）	无	无	0
    AB（0-1）	[A]	[B]	无	0
    ABC（0-2）	[A, AB]	[BC, C]	无	0
    ABCD（0-3）	[A, AB, ABC]	[BCD, CD, D]	无	0
    ABCDA（0-4）	[A, AB, ABC, ABCD]	[BCDA, CDA, DA, A]	A（前缀的 A vs 后缀的 A）	1
    ABCDAB（0-5）	[A,AB,ABC,ABCD,ABCDA]	[BCDAB,CDAB,DAB,AB,B]	AB（前缀的 AB vs 后缀的 AB）	2
    ABCDABD（0-6）	太长不写，总之前缀和后缀没有相同子串	无	0
    最终，模式串 “ABCDABD” 的部分匹配表就是：[0, 0, 0, 0, 1, 2, 0]
    四、KMP 匹配实操：用部分匹配表避开重复比较
    有了部分匹配表，我们就可以开始匹配了。先定两个指针：
    i：主串的指针（永远不回退，只前进）；
    j：模式串的指针（只根据部分匹配表回退，不回退到 0）。
    匹配规则就 3 条：
    若主串[i] == 模式串[j]：i 和 j 一起往后移（i++，j++）；
    若主串[i] != 模式串[j]：
    若 j≠0：j 回退到 “部分匹配表中 j-1 位置的值”（用之前的规律跳过重复）；
    若 j=0：说明模式串第一个字符就不匹配，i 直接后移（i++）；
    若 j == 模式串长度：说明找到匹配了，返回i - j（匹配的起始位置）。
    实战：主串 “BBC ABCDAB ABCDABCDABDE” 找模式串 “ABCDABD”
    主串简化为：B B C A B C D A B A B C D A B C D A B D E（空格是为了看清楚），模式串是A B C D A B D（部分匹配表[0,0,0,0,1,2,0]）。
    我们一步步走：
    初始：i=0，j=0。主串 [0] 是 B，模式串 [0] 是 A → 不匹配，j=0→i++（i=1）；
    i=1：主串 [1] 是 B vs A → 不匹配，i++（i=2）；
    i=2：主串 [2] 是 C vs A → 不匹配，i++（i=3）；
    i=3：主串 [3] 是 A vs A → 匹配，i=4，j=1；
    i=4：主串 [4] 是 B vs B → 匹配，i=5，j=2；
    i=5：主串 [5] 是 C vs C → 匹配，i=6，j=3；
    i=6：主串 [6] 是 D vs D → 匹配，i=7，j=4；
    i=7：主串 [7] 是 A vs A → 匹配，i=8，j=5；
    i=8：主串 [8] 是 B vs B → 匹配，i=9，j=6；
    关键一步：i=9，主串 [9] 是空格 vs 模式串 [6] 是 D → 不匹配！
    此时 j=6≠0，所以 j 回退到 “部分匹配表 [j-1]”= 部分匹配表 [5]=2 → j=2；
    现在比较主串 [9]（空格）vs 模式串 [2]（C）→ 不匹配，j=2≠0，回退到部分匹配表 [1]=0 → j=0；
    主串 [9]（空格）vs 模式串 [0]（A）→ 不匹配，j=0→i++（i=10）；
    继续往后走，直到 i=15 时，主串 [15] 开始的 “ABCDABD” 和模式串完全匹配，此时 j=7（模式串长度），所以匹配起始位置是 15-7=8（具体过程可自行推导，核心是 j 只回退到部分匹配表指定的位置，i 不回退）。
    五、KMP 的核心思想总结
    利用历史信息：通过 “部分匹配表” 记录模式串的规律（前缀和后缀的重叠长度），避免重复比较；
    主串不回退：只调整模式串指针，减少无效操作，效率从暴力匹配的 O (n*m)（n 主串长度，m 模式串长度）提升到 O (n+m)（预处理表 O (m)，匹配 O (n)）。
    */







/*


    你的理解核心逻辑完全正确！只是在 “后缀串开始的地方” 这个表述上，我们可以再精准一点，把 “为什么这么移” 的本质说透 —— 这样你就不会只记表面规则，而是能理解背后的复用逻辑。
    简单总结你的判断：“不满足条件时，找最长相等前后缀，然后把下标移到后缀串开始的地方” → 这个思路是对的，只是 “后缀串开始的地方”，本质上等于 “模式串中「最长相等前缀」的下一个位置”（两者是同一个位置，只是描述角度不同）。
    我们用具体例子拆透这个过程，你会更清晰：
    先明确两个关键前提（避免混淆）
    假设现在出现了「不匹配」：
    模式串的指针停在 j 位置（比如模式串 “ABCDABD” 的 j=6，对应字符 “D”）；
    不匹配时，我们看的是「模式串中 j-1 位置的子串」的最长相等前后缀（因为部分匹配表存的是 “每个子串的最长相等前后缀长度”，j-1 对应的子串就是 “从模式串开头到 j-1 的部分”）。
    用例子验证：为什么 “移到后缀开始的地方”=“移到前缀下一个位置”
    还是用模式串 “ABCDABD”（部分匹配表：[0,0,0,0,1,2,0]），假设现在触发回溯：
    场景：主串和模式串在 j=6（字符 “D”）不匹配
    第一步：找 “最长相等前后缀”因为在 j=6 不匹配，我们看「j-1=5 位置的子串」—— 也就是模式串的前 6 个字符 “ABCDAB”。根据部分匹配表，这个子串的最长相等前后缀长度是 2（前缀是 “AB”，后缀也是 “AB”）。
    第二步：确定 “该移到哪个位置”
    你的理解：“移到后缀串开始的地方”。这里的 “后缀串” 是 “ABCDAB” 的后缀 “AB”，它在整个模式串中的位置是 4-5（字符 “A” 在 4，“B” 在 5），所以 “后缀串开始的地方” 是 4？→ 不对，这里需要纠正一个小误区：我们要移的不是 “后缀串在原模式串的开始位置”，而是 “利用前缀和后缀相等的特性，直接复用前缀的匹配结果，把指针移到「前缀的下一个位置」”。
    正确的对应关系：最长相等前后缀的长度是 L=2（这里 L=2），这个 L 其实就是 “前缀的长度”—— 前缀 “AB” 占了模式串的 0-1 位置（长度 2）。既然前缀和后缀相等（后缀 “AB” 和前缀 “AB” 完全一样），说明「后缀 “AB” 已经和主串匹配过了」（因为之前主串和模式串的 j-1 位置前都是匹配的），所以不需要再重新比较这部分，直接从「前缀的下一个位置」开始比较就行。
    前缀的下一个位置就是 L=2（前缀到 1 结束，下一个是 2）—— 而这个位置，正好等于 “后缀串的第一个字符对应的前缀位置”（因为后缀和前缀相等，后缀的第一个字符对应前缀的第一个字符，后缀的匹配结果 = 前缀的匹配结果，所以直接从前缀结束的下一个位置继续）。
    最终回溯结果：模式串指针 j 从 6 移到 L=2（也就是你说的 “后缀串开始对应的可复用位置”），接下来直接比较主串当前位置和模式串 j=2（字符 “C”）即可 —— 跳过了中间 “AB” 的重复比较。
    再用一句话帮你精准定位回溯逻辑
    当模式串在 j 位置和主串不匹配时：
    找「模式串前 j 个字符（即 j-1 结尾的子串）」的最长相等前后缀长度 L（从部分匹配表的 j-1 位置取）；
    把模式串指针 j 移到 L 这个位置 —— 因为 L 是 “最长相等前缀的下一个位置”，也是 “后缀串的匹配结果能复用的起始位置”。
    你的理解已经抓住了 KMP 回溯的核心（利用最长相等前后缀避免重复），只是在 “位置描述” 上稍微调整一下精度，就完全没问题了！


*/



    /*那其实主要就是构建next数组了吧，记录每个长度字串的最长相等前后缀的长度对吧，那具体实现思路怎么办
    你的理解完全正确！KMP 的核心就是构建 next 数组（本质就是 “最长相等前后缀长度表”），只要把 next 数组的实现逻辑搞透，KMP 就掌握了 80%。
    接下来我会用 “双指针 + step-by-step 实例” 拆解 next 数组的实现思路 —— 不直接扔代码，而是先讲 “为什么这么写”，再用具体例子走一遍，最后给简化的代码逻辑，确保你能从 “思路” 到 “落地” 都看懂。
    一、先明确：next 数组的定义
    首先统一概念（避免后续混淆）：对于模式串s（长度为m），next[i]表示模式串的前i+1个字符组成的子串（即s[0..i]）的最长相等前后缀长度。
    比如模式串s = "ABCDABD"（索引 0-6）：
    next[4]对应的子串是s[0..4] = "ABCDA"，最长相等前后缀长度是 1，所以next[4] = 1；
    next[5]对应的子串是s[0..5] = "ABCDAB"，最长相等前后缀长度是 2，所以next[5] = 2。
    二、实现 next 数组的核心思路：双指针追踪
    要计算next[i]，我们需要两个指针来 “追踪前缀和后缀的匹配情况”：
    指针 j：代表 “当前最长相等前缀的末尾位置”（也等于 “当前最长相等前后缀的长度”，因为前缀从 0 开始）；
    指针 i：代表 “当前后缀的末尾位置”（也就是我们正在计算next[i]的目标索引）。
    核心逻辑分两种情况：前缀和后缀匹配、前缀和后缀不匹配，再加上边界处理即可。


    构建next数组的具体步骤，我举个例子

    比如有这么一串ABACABAB
    开始构建
    next[0]=0默认为零
    next[1]=0 A没有前后缀
    next[2]=0，AB没有前后缀
    next[3]=1 ABA前后缀A相等;;;'



*/



}
