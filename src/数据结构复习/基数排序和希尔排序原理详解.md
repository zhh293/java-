# 基数排序和希尔排序原理详解

## 一、基数排序（Radix Sort）

### 1.1 基本原理
基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程从最低位开始，依次按每一位进行排序，直到最高位。

### 1.2 算法思想
- **稳定排序**：基数排序是一种稳定的排序算法
- **分配式排序**：通过分配和收集过程来实现排序
- **按位排序**：从最低位到最高位依次进行排序

### 1.3 算法步骤
1. 找出数组中的最大数，确定最大位数
2. 从最低位（个位）开始，对每一位进行计数排序
3. 重复步骤2，直到处理完最高位
4. 每一轮排序都保持相对顺序不变（稳定性）

### 1.4 详细实现过程
```
例如：对数组 [170, 45, 75, 90, 2, 802, 24, 66] 进行基数排序

初始数组: [170, 45, 75, 90, 2, 802, 24, 66]

第1轮（个位）: 按个位数字排序
- 个位数字: [0, 5, 5, 0, 2, 2, 4, 6]
- 排序后: [170, 90, 2, 802, 24, 45, 75, 66]

第2轮（十位）: 按十位数字排序
- 十位数字: [7, 9, 0, 0, 2, 4, 7, 6]
- 排序后: [2, 802, 24, 45, 66, 170, 75, 90]

第3轮（百位）: 按百位数字排序
- 百位数字: [0, 8, 0, 0, 0, 1, 0, 0]
- 排序后: [2, 24, 45, 66, 75, 90, 170, 802]
```

### 1.5 时间复杂度
- **时间复杂度**：O(d×(n+k))，其中d是位数，n是元素个数，k是基数（通常是10）
- **空间复杂度**：O(n+k)
- **稳定性**：稳定

### 1.6 适用场景
- 整数排序（可以扩展到字符串）
- 位数较少的数字排序
- 数据分布相对均匀的情况

## 二、希尔排序（Shell Sort）

### 2.1 基本原理
希尔排序是插入排序的一种更高效的改进版本，也称为"缩小增量排序"。其核心思想是将数组分割成若干个子序列，分别进行插入排序，随着增量的减小，子序列包含的元素越来越多，当增量减为1时，整个数组进行一次插入排序。

### 2.2 算法思想
- **分组插入排序**：将数组按一定间隔分成若干组
- **逐步缩小间隔**：间隔逐步缩小直到为1
- **改进的插入排序**：通过预排序使数组接近有序状态

### 2.3 算法步骤
1. 选择一个增量序列（常用的是n/2, n/4, n/8, ..., 1）
2. 按增量将数组分成若干子序列
3. 对每个子序列进行插入排序
4. 减少增量，重复步骤2-3
5. 当增量为1时，进行最后一次插入排序

### 2.4 详细实现过程
```
例如：对数组 [64, 34, 25, 12, 22, 11, 90, 88] 进行希尔排序

初始数组: [64, 34, 25, 12, 22, 11, 90, 88]

增量序列：4, 2, 1

第1轮（增量=4）:
- 子序列1: [64, 22] → [22, 34, 25, 12, 64, 11, 90, 88]
- 子序列2: [34, 11] → [22, 11, 25, 12, 64, 34, 90, 88] 
- 子序列3: [25, 90] → [22, 11, 25, 12, 64, 34, 90, 88]
- 子序列4: [12, 88] → [22, 11, 25, 12, 64, 34, 90, 88]

第2轮（增量=2）:
- 子序列1: [22, 25, 64, 90] → [22, 11, 25, 12, 64, 34, 90, 88]
- 子序列2: [11, 12, 34, 88] → [22, 11, 25, 12, 64, 34, 90, 88]

第3轮（增量=1）:
- 整个数组进行插入排序 → [11, 12, 22, 25, 34, 64, 88, 90]
```

### 2.5 增量序列选择
- **Shell增量序列**：n/2, n/4, n/8, ..., 1
- **Knuth增量序列**：(3^k-1)/2
- **Sedgewick增量序列**：更复杂的数学序列

### 2.6 时间复杂度
- **时间复杂度**：取决于增量序列的选择
  - 最坏情况：O(n²)（使用Shell增量序列）
  - 平均情况：O(n^1.3) 到 O(n^1.5)（使用好的增量序列）
  - 最好情况：O(n log n)
- **空间复杂度**：O(1)
- **稳定性**：不稳定

### 2.7 适用场景
- 中等规模的数据排序
- 对时间复杂度要求不是最严格的场景
- 内存受限的环境

## 三、考试常见题型分析

### 3.1 排序过程跟踪题
**题型**：给出数组，要求写出希尔排序或基数排序前几轮的结果

**解题要点**：
- 希尔排序：明确增量序列，按增量分组，对每组进行插入排序
- 基数排序：从最低位开始，逐位进行计数排序

### 3.2 希尔排序示例
```
数组：[49, 38, 65, 97, 76, 13, 27, 49, 55, 4]
增量序列：5, 3, 1

第1轮（增量=5）：
- 分组：[49,13], [38,27], [65,49], [97,55], [76,4]
- 排序后：[13, 27, 49, 55, 4, 49, 38, 65, 97, 76]

第2轮（增量=3）：
- 分组：[13,55,38], [27,4,65], [49,49,97], [55,76]
- 排序后：[13, 4, 49, 27, 38, 55, 49, 65, 97, 76]

第3轮（增量=1）：
- 整体插入排序：[4, 13, 27, 38, 49, 49, 55, 65, 76, 97]
```

### 3.3 基数排序示例
```
数组：[170, 45, 75, 90, 2, 802, 24, 66]
最大位数：3位

第1轮（个位）：
- 按个位排序：[170, 90, 2, 802, 24, 45, 75, 66]

第2轮（十位）：
- 按十位排序：[2, 802, 24, 45, 66, 170, 75, 90]

第3轮（百位）：
- 按百位排序：[2, 24, 45, 66, 75, 90, 170, 802]
```

## 四、算法实现代码

### 4.1 基数排序实现
```cpp
void radixSort(int arr[], int n) {
    // 找到最大值以确定位数
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    
    // 从个位开始，对每一位进行计数排序
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSortByDigit(arr, n, exp);
    }
}

void countingSortByDigit(int arr[], int n, int exp) {
    int output[n];  // 输出数组
    int count[10] = {0};  // 计数数组
    
    // 统计每个数字出现的次数
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }
    
    // 计算累积计数
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    
    // 复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}
```

### 4.2 希尔排序实现
```cpp
void shellSort(int arr[], int n) {
    // 从大间隔开始，逐步减小间隔
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个子序列进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            // 在子序列中进行插入排序
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}
```

## 五、算法比较

| 特性 | 基数排序 | 希尔排序 |
|------|----------|----------|
| 算法类型 | 分配式排序 | 交换式排序 |
| 时间复杂度 | O(d×(n+k)) | O(n^1.3~n^2) |
| 空间复杂度 | O(n+k) | O(1) |
| 稳定性 | 稳定 | 不稳定 |
| 适用数据 | 整数或固定长度字符串 | 一般数值数据 |
| 最好情况 | 数据分布均匀 | 增量序列选择好 |
| 最坏情况 | 位数很多时 | Shell增量序列 |

## 六、考试注意事项

### 6.1 基数排序注意事项
- 只适用于整数或固定长度的字符串
- 需要额外的存储空间
- 稳定排序算法
- 位数越多，效率越低

### 6.2 希尔排序注意事项
- 不稳定排序算法
- 增量序列的选择影响性能
- 比简单插入排序效率高
- 是插入排序的改进版本

掌握这两种排序算法的原理和过程跟踪方法，对于应对考试中的排序算法题目非常有帮助。