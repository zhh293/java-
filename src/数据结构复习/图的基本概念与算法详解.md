# 图的基本概念与算法详解

## 一、图的基本概念

### 1.1 图的定义
图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为 G(V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

### 1.2 图的基本术语
- **顶点（Vertex）**：图中的数据元素
- **边（Edge）**：连接两个顶点的线段
- **弧（Arc）**：有向图中的边，有方向性
- **有向图（Directed Graph）**：边有方向的图
- **无向图（Undirected Graph）**：边没有方向的图
- **完全图（Complete Graph）**：任意两个顶点之间都存在边的图
  - 无向完全图：n个顶点有n(n-1)/2条边
  - 有向完全图：n个顶点有n(n-1)条弧
- **稀疏图与稠密图**：边数较少的图称为稀疏图，边数较多的图称为稠密图
- **邻接点（Adjacent Vertex）**：一条边连接的两个顶点互为邻接点
- **顶点的度（Degree）**：在无向图中，与顶点v相关联的边的条数
  - 入度（In-degree）：有向图中以顶点v为终点的弧的条数
  - 出度（Out-degree）：有向图中以顶点v为起点的弧的条数
  - 顶点的度 = 入度 + 出度

### 1.3 路径相关概念
- **路径（Path）**：从顶点vi到顶点vj的一条路径是顶点的序列
- **路径长度**：路径上边或弧的数目
- **简单路径**：序列中顶点不重复出现的路径
- **回路/环（Cycle）**：第一个顶点和最后一个顶点相同的路径
- **简单回路/简单环**：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路

### 1.4 连通性相关概念
- **连通**：在无向图中，若从顶点vi到vj有路径，则称vi和vj是连通的
- **连通图**：在无向图中，任意两个顶点都是连通的图
- **连通分量**：无向图中的极大连通子图
- **强连通**：在有向图中，若从顶点vi到vj和从vj到vi都有路径，则称vi和vj是强连通的
- **强连通图**：有向图中任意两个顶点都强连通
- **强连通分量**：有向图中的极大强连通子图

### 1.5 生成树与生成森林
- **生成树**：一个连通图的生成树是一个极小连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边
- **生成森林**：在非连通图中，连通分量的生成树组成生成森林

## 二、图的存储结构

### 2.1 邻接矩阵（Adjacency Matrix）
用一个二维数组表示图中顶点之间的邻接关系。

```java
// 邻接矩阵表示图
public class GraphMatrix {
    private int vertices;      // 顶点数
    private int[][] adjMatrix; // 邻接矩阵
    
    public GraphMatrix(int vertices) {
        this.vertices = vertices;
        this.adjMatrix = new int[vertices][vertices];
    }
    
    // 添加边
    public void addEdge(int i, int j) {
        adjMatrix[i][j] = 1;
        adjMatrix[j][i] = 1; // 无向图
    }
    
    // 添加带权重的边
    public void addEdge(int i, int j, int weight) {
        adjMatrix[i][j] = weight;
        adjMatrix[j][i] = weight; // 无向图
    }
}
```

**特点**：
- 优点：实现简单，便于判断任意两个顶点之间是否有边，便于求顶点的度
- 缺点：不便于增加和删除顶点，n个顶点需要n²个存储空间，稀疏图空间浪费严重
- 空间复杂度：O(n²)

### 2.2 邻接表（Adjacency List）
数组与链表相结合的存储方法，为图中每个顶点建立一个单链表。

```java
import java.util.*;

public class GraphList {
    private int vertices;                    // 顶点数
    private List<List<Integer>> adjList;     // 邻接表
    
    public GraphList(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList<>();
        
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    // 添加边
    public void addEdge(int src, int dest) {
        adjList.get(src).add(dest);
        adjList.get(dest).add(src); // 无向图
    }
    
    // 添加带权重的边（使用内部类Edge）
    static class Edge {
        int destination;
        int weight;
        
        public Edge(int dest, int weight) {
            this.destination = dest;
            this.weight = weight;
        }
    }
    
    private List<List<Edge>> weightedAdjList;
    
    public void addWeightedEdge(int src, int dest, int weight) {
        weightedAdjList.get(src).add(new Edge(dest, weight));
        weightedAdjList.get(dest).add(new Edge(src, weight)); // 无向图
    }
}
```

**特点**：
- 优点：节省存储空间，便于增加和删除顶点，便于统计顶点的度
- 缺点：不便于判断两个顶点之间是否有边，不便于统计边的总数
- 空间复杂度：O(n+e)，其中n为顶点数，e为边数

### 2.3 十字链表（Orthogonal List）
有向图的一种链式存储结构，是邻接表和逆邻接表的结合。

### 2.4 邻接多重表（Adjacency Multilist）
无向图的一种链式存储结构，每条边用一个结点表示。

## 三、图的遍历

### 3.1 深度优先搜索（DFS - Depth First Search）
类似于树的先序遍历，尽可能深地搜索图的分支。

```java
import java.util.*;

public class GraphDFS {
    private int vertices;
    private List<List<Integer>> adjacencyList;

    public GraphDFS(int vertices) {
        this.vertices = vertices;
        this.adjacencyList = new ArrayList<>();

        // 初始化邻接表
        for (int i = 0; i < vertices; i++) {
            adjacencyList.add(new ArrayList<>());
        }
    }

    public void addEdge(int source, int destination) {
        adjacencyList.get(source).add(destination);
        // 对于无向图，也需要添加反向边
        adjacencyList.get(destination).add(source);
    }

    /**
     * 深度优先搜索遍历 - 递归实现
     * @param start 起始顶点
     */
    public void dfsRecursive(int start) {
        boolean[] visited = new boolean[vertices];
        System.out.print("DFS递归遍历结果: ");
        dfsRecursiveUtil(start, visited);
        System.out.println();
    }

    private void dfsRecursiveUtil(int vertex, boolean[] visited) {
        visited[vertex] = true;
        System.out.print(vertex + " ");

        // 遍历所有邻接顶点
        for (int adjacent : adjacencyList.get(vertex)) {
            if (!visited[adjacent]) {
                dfsRecursiveUtil(adjacent, visited);
            }
        }
    }

    /**
     * 深度优先搜索遍历 - 迭代实现(使用栈)
     * @param start 起始顶点
     */
    public void dfsIterative(int start) {
        boolean[] visited = new boolean[vertices];
        Stack<Integer> stack = new Stack<>();

        stack.push(start);
        System.out.print("DFS迭代遍历结果: ");

        while (!stack.isEmpty()) {
            int vertex = stack.pop();

            if (!visited[vertex]) {
                visited[vertex] = true;
                System.out.print(vertex + " ");

                // 将邻接顶点压入栈中(逆序压入以保证正确的访问顺序)
                List<Integer> adjacents = adjacencyList.get(vertex);
                for (int i = adjacents.size() - 1; i >= 0; i--) {
                    int adjacent = adjacents.get(i);
                    if (!visited[adjacent]) {
                        stack.push(adjacent);
                    }
                }
            }
        }
        System.out.println();
    }
}
```

**时间复杂度**：
- 邻接矩阵：O(n²)
- 邻接表：O(n+e)

### 3.2 广度优先搜索（BFS - Breadth First Search）
类似于树的按层次遍历，按层次访问图中顶点。

```java
import java.util.*;

public class GraphBFS {
    private int vertices;
    private List<List<Integer>> adjList;
    
    public GraphBFS(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    public void addEdge(int src, int dest) {
        adjList.get(src).add(dest);
        adjList.get(dest).add(src); // 无向图
    }
    
    public void BFS(int startVertex) {
        boolean[] visited = new boolean[vertices];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[startVertex] = true;
        queue.offer(startVertex);
        
        while (!queue.isEmpty()) {
            int currentVertex = queue.poll();
            System.out.print(currentVertex + " ");
            
            Iterator<Integer> it = adjList.get(currentVertex).iterator();
            while (it.hasNext()) {
                int adjVertex = it.next();
                if (!visited[adjVertex]) {
                    visited[adjVertex] = true;
                    queue.offer(adjVertex);
                }
            }
        }
    }
}
```

**时间复杂度**：
- 邻接矩阵：O(n²)
- 邻接表：O(n+e)

## 四、最小生成树（Minimum Spanning Tree）

### 4.1 普里姆算法（Prim's Algorithm）
从一个顶点开始，逐步扩展生成树，每次选择连接已选顶点集合和未选顶点集合的最小权值边。

**算法步骤**：
1. 初始化：选择一个起始顶点，将其加入生成树
2. 选择：在所有连接生成树顶点和非生成树顶点的边中，选择权值最小的边
3. 添加：将该边和对应的顶点加入生成树
4. 重复：重复步骤2-3，直到所有顶点都加入生成树

**时间复杂度**：O(n²)（使用邻接矩阵）

```java
import java.util.*;

public class PrimMST {
    private int vertices;
    private int[][] adjacencyMatrix;

    public PrimMST(int vertices) {
        this.vertices = vertices;
        this.adjacencyMatrix = new int[vertices][vertices];
    }

    public void addEdge(int source, int destination, int weight) {
        if (source >= 0 && source < vertices &&
                destination >= 0 && destination < vertices) {
            adjacencyMatrix[source][destination] = weight;
            adjacencyMatrix[destination][source] = weight; // 无向图
        }
    }

    public List<int[]> primMST() {
        List<int[]> result = new ArrayList<>();
        boolean[] inMST = new boolean[vertices]; // 标记顶点是否已在MST中
        int[] minEdge = new int[vertices]; // 到MST的最小边权重
        int[] parent = new int[vertices]; // MST中每个顶点的父节点

        // 初始化
        Arrays.fill(minEdge, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);

        // 从顶点0开始
        minEdge[0] = 0;

        // MST需要包含所有顶点
        for (int count = 0; count < vertices; count++) {
            // 找到不在MST中且权重最小的顶点
            int u = findMinVertex(minEdge, inMST);

            // 将顶点加入MST
            inMST[u] = true;

            // 如果不是起始顶点，添加边到结果中
            if (parent[u] != -1) {
                result.add(new int[]{parent[u], u, minEdge[u]});
            }

            // 更新相邻顶点的最小边权重
            for (int v = 0; v < vertices; v++) {
                // 如果顶点v不在MST中，且存在边，且通过u到v的边权重更小
                if (!inMST[v] && adjacencyMatrix[u][v] != 0 && 
                    adjacencyMatrix[u][v] < minEdge[v]) {
                    minEdge[v] = adjacencyMatrix[u][v];
                    parent[v] = u;
                }
            }
        }

        return result;
    }

    private int findMinVertex(int[] minEdge, boolean[] inMST) {
        int minWeight = Integer.MAX_VALUE;
        int minVertex = -1;

        for (int v = 0; v < vertices; v++) {
            if (!inMST[v] && minEdge[v] < minWeight) {
                minWeight = minEdge[v];
                minVertex = v;
            }
        }

        return minVertex;
    }
}
```

### 4.2 克鲁斯卡尔算法（Kruskal's Algorithm）
按权值从小到大考虑所有边，如果边的两个顶点属于不同的连通分量，则将该边加入生成树。

**算法步骤**：
1. 将所有边按权值从小到大排序
2. 初始化并查集，每个顶点为一个独立集合
3. 依次考虑每条边，如果边的两个顶点不在同一集合中，则将该边加入生成树，并合并两个集合
4. 重复步骤3，直到生成树有n-1条边

**时间复杂度**：O(e log e)，其中e为边数

```java
import java.util.*;

public class KruskalMST {
    static class Edge implements Comparable<Edge> {
        int source;
        int destination;
        int weight;

        public Edge(int source, int destination, int weight) {
            this.source = source;
            this.destination = destination;
            this.weight = weight;
        }

        @Override
        public int compareTo(Edge other) {
            return Integer.compare(this.weight, other.weight);
        }
    }

    static class UnionFind {
        private int[] parent;
        private int[] rank;

        public UnionFind(int size) {
            parent = new int[size];
            rank = new int[size];
            for (int i = 0; i < size; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }

        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // 路径压缩
            }
            return parent[x];
        }

        public boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);

            if (rootX == rootY) {
                return false; // 已经在同一个集合中
            }

            // 按秩合并
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            return true;
        }
    }

    static class Graph {
        private int vertices;
        private List<Edge> edges;

        public Graph(int vertices) {
            this.vertices = vertices;
            this.edges = new ArrayList<>();
        }

        public void addEdge(int source, int destination, int weight) {
            edges.add(new Edge(source, destination, weight));
        }

        public List<Edge> kruskalMST() {
            List<Edge> result = new ArrayList<>();

            // 1. 按权重排序所有边
            Collections.sort(edges);

            // 2. 初始化并查集
            UnionFind uf = new UnionFind(vertices);

            // 3. 遍历排序后的边
            for (Edge edge : edges) {
                // 如果添加这条边不会形成环，则加入MST
                if (uf.union(edge.source, edge.destination)) {
                    result.add(edge);
                    // MST有V-1条边
                    if (result.size() == vertices - 1) {
                        break;
                    }
                }
            }

            return result;
        }
    }
}
```

## 五、最短路径算法

### 5.1 单源最短路径 - 迪杰斯特拉算法（Dijkstra's Algorithm）
求从源点到其他各顶点的最短路径。

**算法特点**：
- 适用于边权值非负的图
- 使用贪心策略
- 时间复杂度：O(n²)（使用邻接矩阵）

```java
import java.util.*;

public class Dijkstra {
    private int vertices;
    private int[][] adjacencyMatrix;

    public Dijkstra(int vertices) {
        this.vertices = vertices;
        this.adjacencyMatrix = new int[vertices][vertices];

        // 初始化邻接矩阵，用Integer.MAX_VALUE表示无连接
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                if (i == j) {
                    adjacencyMatrix[i][j] = 0;
                } else {
                    adjacencyMatrix[i][j] = Integer.MAX_VALUE;
                }
            }
        }
    }

    public void addEdge(int source, int destination, int weight) {
        if (source >= 0 && source < vertices &&
                destination >= 0 && destination < vertices) {
            adjacencyMatrix[source][destination] = weight;
        }
    }

    public int[] dijkstra(int source) {
        // 存储从源顶点到各顶点的最短距离
        int[] distances = new int[vertices];

        // 记录顶点是否已被处理
        boolean[] processed = new boolean[vertices];

        // 初始化距离数组
        Arrays.fill(distances, Integer.MAX_VALUE);
        Arrays.fill(processed, false);

        // 源顶点到自身的距离为0
        distances[source] = 0;

        // 对每个顶点进行处理
        for (int count = 0; count < vertices - 1; count++) {
            // 找到未处理顶点中距离最小的顶点
            int u = minDistance(distances, processed);

            // 标记该顶点已处理
            processed[u] = true;

            // 更新与顶点u相邻的顶点的距离值
            for (int v = 0; v < vertices; v++) {
                // 如果顶点v未被处理，且存在从u到v的边，
                // 且通过u可以获得更短路径，则更新距离
                if (!processed[v] &&
                        adjacencyMatrix[u][v] != Integer.MAX_VALUE &&
                        distances[u] != Integer.MAX_VALUE &&
                        distances[u] + adjacencyMatrix[u][v] < distances[v]) {

                    distances[v] = distances[u] + adjacencyMatrix[u][v];
                }
            }
        }

        return distances;
    }

    private int minDistance(int[] distances, boolean[] processed) {
        int min = Integer.MAX_VALUE;
        int minIndex = -1;

        for (int v = 0; v < vertices; v++) {
            if (!processed[v] && distances[v] <= min) {
                min = distances[v];
                minIndex = v;
            }
        }

        return minIndex;
    }
}
```

### 5.2 单源最短路径 - 贝尔曼-福特算法（Bellman-Ford Algorithm）
可以处理负权边，但不能处理负权回路。

**时间复杂度**：O(ve)，其中v为顶点数，e为边数

### 5.3 多源最短路径 - 弗洛伊德算法（Floyd-Warshall Algorithm）
求每对顶点之间的最短路径。

**时间复杂度**：O(n³)

```java
public class FloydWarshall {
    private int vertices;
    private int[][] adjacencyMatrix;

    public FloydWarshall(int vertices) {
        this.vertices = vertices;
        this.adjacencyMatrix = new int[vertices][vertices];

        // 初始化邻接矩阵，用Integer.MAX_VALUE表示无连接
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                if (i == j) {
                    adjacencyMatrix[i][j] = 0;
                } else {
                    adjacencyMatrix[i][j] = Integer.MAX_VALUE;
                }
            }
        }
    }

    public void addEdge(int source, int destination, int weight) {
        if (source >= 0 && source < vertices &&
                destination >= 0 && destination < vertices) {
            adjacencyMatrix[source][destination] = weight;
        }
    }

    public int[][] floydWarshall() {
        // 创建距离矩阵副本
        int[][] dist = new int[vertices][vertices];

        // 初始化距离矩阵
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                dist[i][j] = adjacencyMatrix[i][j];
            }
        }

        // Floyd-Warshall核心算法
        // k为中间顶点
        for (int k = 0; k < vertices; k++) {
            // i为起始顶点
            for (int i = 0; i < vertices; i++) {
                // j为目标顶点
                for (int j = 0; j < vertices; j++) {
                    // 如果经过顶点k可以获得更短路径，则更新距离
                    if (dist[i][k] != Integer.MAX_VALUE &&
                            dist[k][j] != Integer.MAX_VALUE &&
                            dist[i][k] + dist[k][j] < dist[i][j]) {

                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        return dist;
    }
}
```

## 六、拓扑排序（Topological Sort）

### 6.1 拓扑排序定义
对一个有向无环图（DAG）进行拓扑排序，是将图中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E，则u在线性序列中出现在v之前。

### 6.2 拓扑排序算法
**方法一：入度为0顶点删除法（Kahn算法）**
1. 计算每个节点的入度
2. 将入度为0的节点加入队列
3. 从队列中取出节点，并减少其邻居节点的入度
4. 如果邻居节点入度变为0，则将其加入队列
5. 重复直到队列为空

**时间复杂度**：O(n+e)

```java
import java.util.*;

public class TopologicalSort {
    private int vertices;
    private List<List<Integer>> adjacencyList;

    public TopologicalSort(int vertices) {
        this.vertices = vertices;
        this.adjacencyList = new ArrayList<>();

        // 初始化邻接表
        for (int i = 0; i < vertices; i++) {
            adjacencyList.add(new ArrayList<>());
        }
    }

    public void addEdge(int from, int to) {
        adjacencyList.get(from).add(to);
    }

    public List<Integer> topologicalSort() {
        // 存储每个节点的入度
        int[] inDegree = new int[vertices];

        // 计算每个节点的入度
        for (int i = 0; i < vertices; i++) {
            for (int neighbor : adjacencyList.get(i)) {
                inDegree[neighbor]++;
            }
        }

        // 将所有入度为0的节点加入队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }

        // 存储拓扑排序结果
        List<Integer> result = new ArrayList<>();

        // 处理队列中的节点
        while (!queue.isEmpty()) {
            // 取出入度为0的节点
            int current = queue.poll();
            result.add(current);

            // 更新其邻居节点的入度
            for (int neighbor : adjacencyList.get(current)) {
                inDegree[neighbor]--;

                // 如果邻居节点入度变为0，加入队列
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }

        // 检查是否存在环
        // 如果拓扑排序包含所有节点，则无环；否则存在环
        if (result.size() != vertices) {
            System.out.println("图中存在环，无法进行拓扑排序");
            return new ArrayList<>(); // 返回空列表表示排序失败
        }

        return result;
    }
}
```

## 七、关键路径（Critical Path）

### 7.1 AOV网与AOE网
- **AOV网（Activity On Vertex Network）**：用顶点表示活动的网络
- **AOE网（Activity On Edge Network）**：用边表示活动的网络，边有权值表示活动持续时间

### 7.2 关键路径概念
在AOE网中，从开始顶点到完成顶点的最长路径长度为完成整个工程的最短时间，这样的路径称为关键路径。

## 八、考试重点与常见题型

### 8.1 概念理解题
- 图的基本术语的理解
- 有向图与无向图的区别
- 连通性相关概念的区分

### 8.2 存储结构转换题
- 邻接矩阵与邻接表的相互转换
- 不同存储结构的空间复杂度计算

### 8.3 遍历算法应用题
- 给定图，写出DFS和BFS遍历序列
- 根据遍历序列还原图的结构

### 8.4 算法执行过程题
- 最小生成树算法（Prim、Kruskal）的执行过程
- 最短路径算法（Dijkstra、Floyd）的执行过程
- 拓扑排序的执行过程

### 8.5 时间复杂度分析题
- 各种图算法的时间复杂度分析
- 不同存储结构对算法效率的影响

## 九、重要公式总结

| 计算类型 | 公式 | 说明 |
|---------|------|------|
| 无向完全图边数 | n(n-1)/2 | n个顶点的无向完全图 |
| 有向完全图弧数 | n(n-1) | n个顶点的有向完全图 |
| 生成树边数 | n-1 | n个顶点的连通图的生成树 |
| 邻接矩阵空间复杂度 | O(n²) | n个顶点的邻接矩阵 |
| 邻接表空间复杂度 | O(n+e) | n个顶点、e条边的邻接表 |

## 十、易错点与注意事项

1. **度的计算**：无向图的度、有向图的入度和出度要区分清楚
2. **连通性判断**：连通图、强连通图、连通分量的概念要准确理解
3. **算法适用条件**：Dijkstra算法不能处理负权边，Floyd算法可以处理负权边但不能处理负权回路
4. **时间复杂度**：不同存储结构下算法的时间复杂度可能不同
5. **最小生成树**：Prim算法适合稠密图，Kruskal算法适合稀疏图

图是数据结构中的重要内容，掌握基本概念、存储结构和经典算法对于考试和实际应用都非常重要。