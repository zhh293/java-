# 关键路径详解

## 一、关键路径概述

### 1.1 基本概念

**关键路径（Critical Path）**：在一个有向无环图（AOE网）中，从开始顶点到完成顶点的最长路径长度为完成整个工程的最短时间，这样的路径称为关键路径。

**AOE网（Activity On Edge Network）**：用边表示活动的网络，边有权值表示活动持续时间的有向图。

**AOV网（Activity On Vertex Network）**：用顶点表示活动的网络。

### 1.2 关键路径的特点

1. **最长路径**：关键路径是AOE网中的最长路径
2. **决定工期**：关键路径的长度决定了整个工程的最短完成时间
3. **无缓冲时间**：关键路径上的活动没有时间余量，延误会影响总工期
4. **可能不唯一**：一个工程可能存在多条关键路径

### 1.3 关键路径的意义

- **工期控制**：通过控制关键路径上的活动来控制整个工程的工期
- **资源分配**：优先保证关键路径上的资源供应
- **进度管理**：监控关键路径上的活动进度，确保工程按时完成

## 二、关键路径相关术语

### 2.1 事件时间参数

1. **事件的最早发生时间（ve(j)）**：
   - 从开始顶点到顶点j的最长路径长度
   - 表示事件j最早可以发生的时刻

2. **事件的最迟发生时间（vl(j)）**：
   - 在保证工期的前提下，事件j最迟必须发生的时刻
   - vl(j) = min{vl(k) - weight(j, k)}

### 2.2 活动时间参数

1. **活动的最早开始时间（e(i)）**：
   - e(i) = ve(j)，其中j是活动i的起始顶点

2. **活动的最迟开始时间（l(i)）**：
   - l(i) = vl(k) - weight(i)，其中k是活动i的终止顶点

3. **活动的时间余量（d(i)）**：
   - d(i) = l(i) - e(i)
   - 表示活动可以推迟的时间

### 2.3 关键活动

**关键活动**：时间余量为0的活动，即d(i) = 0的活动。
关键活动的开始时间不能推迟，否则会影响整个工程的完成时间。

## 三、关键路径算法步骤

### 3.1 算法步骤

1. **拓扑排序**：对AOE网进行拓扑排序，确定顶点的处理顺序

2. **计算事件的最早发生时间ve(j)**：
   - 初始化：ve(源点) = 0
   - 按拓扑排序顺序计算：ve(j) = max{ve(i) + weight(i, j)}

3. **计算事件的最迟发生时间vl(j)**：
   - 初始化：vl(汇点) = ve(汇点)
   - 按逆拓扑排序顺序计算：vl(i) = min{vl(j) - weight(i, j)}

4. **计算活动的最早开始时间e(i)和最迟开始时间l(i)**：
   - e(i) = ve(j)，j为活动i的起始顶点
   - l(i) = vl(k) - weight(i)，k为活动i的终止顶点

5. **确定关键活动**：
   - 当e(i) = l(i)时，活动i为关键活动

6. **输出关键路径**：
   - 由关键活动构成的从源点到汇点的路径

### 3.2 算法实现

```java
import java.util.*;

public class CriticalPath {
    static class Edge {
        int to;        // 终点
        int weight;    // 权重（活动持续时间）
        
        Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    private int vertices;           // 顶点数
    private List<List<Edge>> adjList;  // 邻接表
    private int[] ve;               // 事件最早发生时间
    private int[] vl;               // 事件最迟发生时间
    private int[] inDegree;         // 入度数组
    
    public CriticalPath(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList<>();
        this.ve = new int[vertices];
        this.vl = new int[vertices];
        this.inDegree = new int[vertices];
        
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    public void addEdge(int from, int to, int weight) {
        adjList.get(from).add(new Edge(to, weight));
        inDegree[to]++;
    }
    
    public void findCriticalPath() {
        // 1. 拓扑排序并计算ve数组
        topologicalSort();
        
        // 2. 计算vl数组
        calculateVL();
        
        // 3. 找出关键活动
        findCriticalActivities();
    }
    
    private void topologicalSort() {
        // 初始化ve数组
        Arrays.fill(ve, 0);
        
        Queue<Integer> queue = new LinkedList<>();
        int[] tempInDegree = Arrays.copyOf(inDegree, vertices);
        
        // 将入度为0的顶点入队
        for (int i = 0; i < vertices; i++) {
            if (tempInDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        while (!queue.isEmpty()) {
            int current = queue.poll();
            
            // 更新当前顶点的邻接顶点的ve值
            for (Edge edge : adjList.get(current)) {
                // 更新邻接顶点的最早发生时间
                if (ve[current] + edge.weight > ve[edge.to]) {
                    ve[edge.to] = ve[current] + edge.weight;
                }
                
                tempInDegree[edge.to]--;
                if (tempInDegree[edge.to] == 0) {
                    queue.offer(edge.to);
                }
            }
        }
    }
    
    private void calculateVL() {
        // 初始化vl数组为无穷大，汇点为ve[汇点]
        Arrays.fill(vl, Integer.MAX_VALUE);
        int sink = 0;  // 假设编号最大的点是汇点
        for (int i = 0; i < vertices; i++) {
            if (ve[i] > ve[sink]) {
                sink = i;
            }
        }
        vl[sink] = ve[sink];
        
        // 按逆拓扑排序计算vl数组
        Stack<Integer> stack = new Stack<>();
        int[] tempInDegree = Arrays.copyOf(inDegree, vertices);
        Queue<Integer> queue = new LinkedList<>();
        
        // 重新拓扑排序以获得逆序
        for (int i = 0; i < vertices; i++) {
            if (tempInDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        while (!queue.isEmpty()) {
            int current = queue.poll();
            stack.push(current);
            
            for (Edge edge : adjList.get(current)) {
                tempInDegree[edge.to]--;
                if (tempInDegree[edge.to] == 0) {
                    queue.offer(edge.to);
                }
            }
        }
        
        // 按逆拓扑顺序计算vl
        while (!stack.isEmpty()) {
            int current = stack.pop();
            for (Edge edge : adjList.get(current)) {
                if (vl[edge.to] - edge.weight < vl[current]) {
                    vl[current] = vl[edge.to] - edge.weight;
                }
            }
        }
    }
    
    private void findCriticalActivities() {
        System.out.println("关键活动：");
        boolean hasCriticalPath = false;
        
        for (int i = 0; i < vertices; i++) {
            for (Edge edge : adjList.get(i)) {
                int e = ve[i];           // 活动最早开始时间
                int l = vl[edge.to] - edge.weight;  // 活动最迟开始时间
                
                if (e == l) {
                    System.out.println("活动 " + i + " -> " + edge.to + 
                                     " (持续时间: " + edge.weight + ") 是关键活动");
                    hasCriticalPath = true;
                }
            }
        }
        
        if (!hasCriticalPath) {
            System.out.println("未找到关键活动");
        }
        
        System.out.println("工程最短完成时间: " + ve[vertices - 1]);
    }
}
```

## 四、关键路径解题过程示例

### 4.1 示例图

假设有一个AOE网，包含6个事件（顶点0-5）：

```
     a1(6)    a4(1)    a7(4)
0 --------> 1 ------> 3 ------> 5
 |  a2(4)   |  a5(1)   |  a8(2)
 |---------> 2 ------> 4 ------> 5
     a3(5)    a6(2)
```

### 4.2 解题步骤

**第1步：拓扑排序**
- 拓扑序列：0, 1, 2, 3, 4, 5

**第2步：计算ve数组（事件最早发生时间）**
- ve(0) = 0
- ve(1) = max{ve(0) + 6} = 6
- ve(2) = max{ve(0) + 4, ve(0) + 5} = 5
- ve(3) = max{ve(1) + 1, ve(2) + 2} = max{7, 7} = 7
- ve(4) = max{ve(2) + 1} = 6
- ve(5) = max{ve(3) + 4, ve(4) + 2} = max{11, 8} = 11

**第3步：计算vl数组（事件最迟发生时间）**
- vl(5) = ve(5) = 11
- vl(4) = vl(5) - 2 = 9
- vl(3) = vl(5) - 4 = 7
- vl(2) = min{vl(3) - 2, vl(4) - 1} = min{5, 8} = 5
- vl(1) = vl(3) - 1 = 6
- vl(0) = min{vl(1) - 6, vl(2) - 4, vl(2) - 5} = min{0, 1, 0} = 0

**第4步：计算活动时间参数**
- 活动a1: e=0, l=6-6=0, d=0-0=0 → 关键活动
- 活动a2: e=0, l=6-4=2, d=2-0=2 → 非关键活动
- 活动a3: e=0, l=5-5=0, d=0-0=0 → 关键活动
- 活动a4: e=6, l=7-1=6, d=6-6=0 → 关键活动
- 活动a5: e=5, l=7-2=5, d=5-5=0 → 关键活动
- 活动a6: e=5, l=6-1=5, d=5-5=0 → 关键活动
- 活动a7: e=7, l=11-4=7, d=7-7=0 → 关键活动
- 活动a8: e=6, l=11-2=9, d=9-6=3 → 非关键活动

**第5步：确定关键路径**
- 关键路径：0 → 2 → 4 → 3 → 5
- 或者：0 → 2 → 3 → 5

## 五、关键路径计算表格

| 事件 | ve | vl | 关键事件 |
|------|----|----|----------|
| 0    | 0  | 0  | 是       |
| 1    | 6  | 6  | 是       |
| 2    | 5  | 5  | 是       |
| 3    | 7  | 7  | 是       |
| 4    | 6  | 9  | 否       |
| 5    | 11 | 11 | 是       |

## 六、考试重点与常见题型

### 6.1 概念理解题
- 区分AOE网和AOV网
- 理解关键路径、关键活动的定义
- 掌握时间参数的含义和计算方法

### 6.2 计算题
- 给定AOE网，计算各事件的ve和vl
- 计算各活动的e、l、d值
- 确定关键路径和关键活动
- 计算工程最短完成时间

### 6.3 分析题
- 分析关键路径对工程工期的影响
- 识别影响工期的关键活动
- 评估资源分配策略

## 七、解题技巧与注意事项

### 7.1 解题技巧

1. **画图清晰**：先画出清晰的AOE网图，标出边的权值
2. **拓扑排序**：按拓扑顺序计算ve，按逆拓扑顺序计算vl
3. **逐层计算**：按层次逐步计算各参数，避免遗漏
4. **验证结果**：检查关键路径长度是否等于ve(汇点)

### 7.2 常见错误

1. **计算ve时**：忘记取最大值，导致事件时间计算错误
2. **计算vl时**：忘记取最小值，或起始值设置错误
3. **活动参数计算**：混淆起始顶点和终止顶点
4. **关键活动判断**：d=0的条件判断错误

### 7.3 记忆要点

1. **ve计算**：从前向后，取最大值
2. **vl计算**：从后向前，取最小值
3. **关键活动**：e = l，即d = 0
4. **工期**：等于ve(汇点)

## 八、练习题

### 8.1 基础练习题
给定一个AOE网，包含以下活动：
- 活动1: 0→1, 权值=3
- 活动2: 0→2, 权值=2
- 活动3: 1→3, 权值=4
- 活动4: 2→3, 权值=5
- 活动5: 3→4, 权值=2

求关键路径和工程最短完成时间。

### 8.2 综合练习题
分析一个复杂的工程项目，包含多个并行活动，计算关键路径并分析如何缩短工期。

## 九、实际应用

### 9.1 项目管理
- 工程进度控制
- 资源优化配置
- 工期风险评估

### 9.2 系统设计
- 任务调度优化
- 性能瓶颈分析
- 并行处理设计

关键路径是项目管理和系统分析中的重要概念，掌握其计算方法对于工程实践和考试都具有重要意义。