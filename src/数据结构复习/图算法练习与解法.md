# 图算法练习与解法

## 一、图的表示与基本操作

### 1.1 邻接矩阵与邻接表转换

**题目**：给定一个无向图的邻接矩阵，将其转换为邻接表表示。

**解法**：
```java
import java.util.*;

public class GraphConversion {
    // 邻接矩阵转邻接表
    public static List<List<Integer>> matrixToAdjList(int[][] matrix) {
        int n = matrix.length;
        List<List<Integer>> adjList = new ArrayList<>();
        
        // 初始化邻接表
        for (int i = 0; i < n; i++) {
            adjList.add(new ArrayList<>());
        }
        
        // 遍历邻接矩阵，找到边并添加到邻接表
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] != 0) {  // 存在边
                    adjList.get(i).add(j);
                }
            }
        }
        
        return adjList;
    }
    
    // 邻接表转邻接矩阵
    public static int[][] adjListToMatrix(List<List<Integer>> adjList) {
        int n = adjList.size();
        int[][] matrix = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j : adjList.get(i)) {
                matrix[i][j] = 1;
            }
        }
        
        return matrix;
    }
}
```

### 1.2 计算顶点的度

**题目**：在邻接矩阵和邻接表中如何计算顶点的度？

**解法**：
```java
public class VertexDegree {
    // 邻接矩阵中计算无向图顶点的度
    public static int degreeInMatrix(int[][] matrix, int vertex) {
        int degree = 0;
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[vertex][i] != 0) {
                degree++;
            }
        }
        return degree;
    }
    
    // 邻接表中计算无向图顶点的度
    public static int degreeInAdjList(List<List<Integer>> adjList, int vertex) {
        return adjList.get(vertex).size();
    }
    
    // 有向图的入度和出度
    public static int[] inAndOutDegree(int[][] matrix, int vertex) {
        int inDegree = 0, outDegree = 0;
        
        // 出度：行中非零元素的个数
        for (int j = 0; j < matrix.length; j++) {
            if (matrix[vertex][j] != 0) {
                outDegree++;
            }
        }
        
        // 入度：列中非零元素的个数
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[i][vertex] != 0) {
                inDegree++;
            }
        }
        
        return new int[]{inDegree, outDegree};
    }
}
```

## 二、图的遍历算法练习

### 2.1 DFS路径查找

**题目**：查找图中两个顶点之间是否存在路径，并返回路径。

**解法**：
```java
import java.util.*;

public class PathFinder {
    public static List<Integer> findPathDFS(List<List<Integer>> adjList, 
                                           int start, int end) {
        int n = adjList.size();
        boolean[] visited = new boolean[n];
        List<Integer> path = new ArrayList<>();
        
        if (dfsUtil(adjList, start, end, visited, path)) {
            return path;
        }
        return new ArrayList<>(); // 无路径
    }
    
    private static boolean dfsUtil(List<List<Integer>> adjList, int current, 
                                  int end, boolean[] visited, List<Integer> path) {
        visited[current] = true;
        path.add(current);
        
        if (current == end) {
            return true;
        }
        
        for (int neighbor : adjList.get(current)) {
            if (!visited[neighbor]) {
                if (dfsUtil(adjList, neighbor, end, visited, path)) {
                    return true;
                }
            }
        }
        
        // 回溯
        path.remove(path.size() - 1);
        return false;
    }
}
```

### 2.2 BFS最短路径

**题目**：使用BFS找到两个顶点之间的最短路径。

**解法**：
```java
import java.util.*;

public class ShortestPathBFS {
    public static List<Integer> shortestPathBFS(List<List<Integer>> adjList, 
                                               int start, int end) {
        int n = adjList.size();
        boolean[] visited = new boolean[n];
        int[] parent = new int[n];
        
        Arrays.fill(parent, -1);
        
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        visited[start] = true;
        
        while (!queue.isEmpty()) {
            int current = queue.poll();
            
            if (current == end) {
                break;
            }
            
            for (int neighbor : adjList.get(current)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    queue.offer(neighbor);
                }
            }
        }
        
        // 重构路径
        List<Integer> path = new ArrayList<>();
        int current = end;
        while (current != -1) {
            path.add(current);
            current = parent[current];
        }
        
        Collections.reverse(path);
        return path.size() > 1 ? path : new ArrayList<>();
    }
}
```

## 三、连通性相关算法

### 3.1 判断图的连通性

**题目**：判断无向图是否连通。

**解法**：
```java
public class GraphConnectivity {
    public static boolean isConnected(List<List<Integer>> adjList) {
        int n = adjList.size();
        if (n <= 1) return true;
        
        boolean[] visited = new boolean[n];
        dfs(adjList, 0, visited);
        
        // 检查是否所有顶点都被访问
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }
    
    private static void dfs(List<List<Integer>> adjList, int start, boolean[] visited) {
        visited[start] = true;
        for (int neighbor : adjList.get(start)) {
            if (!visited[neighbor]) {
                dfs(adjList, neighbor, visited);
            }
        }
    }
}
```

### 3.2 查找连通分量

**题目**：查找无向图的所有连通分量。

**解法**：
```java
import java.util.*;

public class ConnectedComponents {
    public static List<List<Integer>> findConnectedComponents(List<List<Integer>> adjList) {
        int n = adjList.size();
        boolean[] visited = new boolean[n];
        List<List<Integer>> components = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                List<Integer> component = new ArrayList<>();
                dfs(adjList, i, visited, component);
                components.add(component);
            }
        }
        
        return components;
    }
    
    private static void dfs(List<List<Integer>> adjList, int start, 
                           boolean[] visited, List<Integer> component) {
        visited[start] = true;
        component.add(start);
        
        for (int neighbor : adjList.get(start)) {
            if (!visited[neighbor]) {
                dfs(adjList, neighbor, visited, component);
            }
        }
    }
}
```

## 四、最短路径算法应用

### 4.1 单源最短路径变种

**题目**：在带权图中找到从源点到所有其他点的最短路径。

**解法**：
```java
import java.util.*;

public class DijkstraWithPath {
    static class Node implements Comparable<Node> {
        int vertex;
        int distance;
        
        Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
    
    public static int[] dijkstraWithPQ(int[][] graph, int source) {
        int n = graph.length;
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        PriorityQueue<Node> pq = new PriorityQueue<>();
        
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        pq.offer(new Node(source, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;
            
            if (visited[u]) continue;
            visited[u] = true;
            
            for (int v = 0; v < n; v++) {
                if (!visited[v] && graph[u][v] != 0 && 
                    dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                    pq.offer(new Node(v, dist[v]));
                }
            }
        }
        
        return dist;
    }
}
```

## 五、最小生成树应用

### 5.1 判断是否为MST

**题目**：给定一个图和一组边，判断这组边是否构成最小生成树。

**解法**：
```java
public class MSTChecker {
    static class Edge {
        int u, v, weight;
        Edge(int u, int v, int weight) {
            this.u = u;
            this.v = v;
            this.weight = weight;
        }
    }
    
    static class UnionFind {
        private int[] parent;
        
        UnionFind(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX == rootY) return false;
            parent[rootX] = rootY;
            return true;
        }
    }
    
    public static boolean isMST(int n, int[][] edges, Edge[] mstEdges) {
        if (mstEdges.length != n - 1) return false;
        
        // 使用并查集检查是否形成环
        UnionFind uf = new UnionFind(n);
        for (Edge e : mstEdges) {
            if (!uf.union(e.u, e.v)) {
                return false; // 形成环
            }
        }
        
        // 检查是否连通
        int root = uf.find(0);
        for (int i = 1; i < n; i++) {
            if (uf.find(i) != root) {
                return false; // 不连通
            }
        }
        
        return true;
    }
}
```

## 六、拓扑排序应用

### 6.1 课程安排问题

**题目**：给定课程的先修关系，安排课程学习顺序。

**解法**：
```java
import java.util.*;

public class CourseSchedule {
    public static List<Integer> findOrder(int numCourses, int[][] prerequisites) {
        // 构建邻接表和入度数组
        List<List<Integer>> adjList = new ArrayList<>();
        int[] inDegree = new int[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            adjList.add(new ArrayList<>());
        }
        
        for (int[] pre : prerequisites) {
            adjList.get(pre[1]).add(pre[0]); // pre[1] -> pre[0]
            inDegree[pre[0]]++;
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        while (!queue.isEmpty()) {
            int current = queue.poll();
            result.add(current);
            
            for (int neighbor : adjList.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        return result.size() == numCourses ? result : new ArrayList<>();
    }
}
```

## 七、图算法复杂度分析

### 7.1 算法时间复杂度对比

| 算法 | 邻接矩阵 | 邻接表 | 适用场景 |
|------|----------|--------|----------|
| DFS/BFS | O(V²) | O(V+E) | 通用 |
| Dijkstra | O(V²) | O((V+E)logV) | 单源最短路径 |
| Floyd-Warshall | O(V³) | O(V³) | 多源最短路径 |
| Prim | O(V²) | O(ElogV) | 稠密图MST |
| Kruskal | O(ElogE) | O(ElogE) | 稀疏图MST |
| 拓扑排序 | O(V²) | O(V+E) | 有向无环图 |

## 八、常见问题与解题技巧

### 8.1 图的建模技巧
- 将实际问题抽象为图论问题
- 确定顶点和边的含义
- 选择合适的图表示方法

### 8.2 算法选择原则
- 根据图的稠密程度选择算法
- 考虑算法的时间和空间复杂度
- 注意算法的适用条件（如Dijkstra不能处理负权边）

### 8.3 常见错误
- 忘记初始化visited数组
- 图的表示方法选择不当
- 没有考虑特殊情况（如空图、孤立点）
- 算法适用条件判断错误

通过这些练习和解法，可以更好地掌握图算法的核心思想和实现细节，为考试和实际应用打下坚实基础。