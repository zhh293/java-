# 算法复杂度核心知识点（考试专用）

# 一、核心概念总览

算法的复杂度是衡量算法效率的核心指标，分为**时间复杂度**（衡量算法执行时间与输入规模的关系）和**空间复杂度**（衡量算法所需存储空间与输入规模的关系）。而**最坏情况**、**平均情况**是针对时间/空间复杂度的具体场景分析，用于更全面地评估算法在不同输入下的表现。

核心考点：复杂度的定义、符号表示、计算步骤、常见复杂度等级，以及最坏/平均情况的判定与计算。

# 二、时间复杂度

## 2.1 定义

时间复杂度是指算法执行过程中**基本操作的执行次数**与输入规模 \( n \) 的函数关系，记为 \( T(n) = O(f(n)) \)（大O记号），表示随着输入规模 \( n \) 的增大，算法执行时间的增长趋势与 \( f(n) \) 一致。

注意：时间复杂度不计算具体执行时间（受硬件、编程语言影响），只关注“增长趋势”，即只保留函数中**增长最快的项**，并忽略该项的系数和常数项。

## 2.2 符号表示（考试常考）

- **大O记号 \( O(f(n)) \)（上界）**：表示算法执行时间不会超过 \( f(n) \) 的增长速度，是最常用的复杂度表示（如 \( O(n) \)、\( O(n^2) \)）。

- **大Ω记号 \( Ω(f(n)) \)（下界）**：表示算法执行时间不会低于 \( f(n) \) 的增长速度（考试较少单独考，多结合最优情况）。

- **大Θ记号 \( Θ(f(n)) \)（紧界）**：表示算法执行时间的增长速度与 \( f(n) \) 完全一致（即 \( T(n) = O(f(n)) \) 且 \( T(n) = Ω(f(n)) \)，如二分查找的时间复杂度是 \( Θ(log n) \)）。

## 2.3 计算步骤（考试核心技能）

1. **确定输入规模 \( n \)**：输入规模是影响算法执行次数的核心变量（如数组长度、字符串长度、矩阵阶数等）。

2. **找出基本操作**：基本操作是算法中执行次数最多的“原子操作”（如赋值、比较、加减运算等，通常一个基本操作执行时间固定）。

3. **统计基本操作的执行次数 \( T(n) \)**：根据算法逻辑，写出 \( T(n) \) 关于 \( n \) 的表达式（分循环、递归等场景分析）。

4. **简化为大O记号**：
        

    - 去掉所有常数项（如 \( T(n) = 2n + 3 \) → 去掉3，得 \( 2n \)）；

    - 去掉最高次项的系数（如 \( 2n \) → \( n \)）；

    - 只保留增长最快的项（如 \( T(n) = n^2 + 5n + 2 \) → 增长最快的是 \( n^2 \)，故 \( O(n^2) \)）。

## 2.4 常见时间复杂度及等级（从优到劣）

|复杂度|名称|常见场景|示例|
|---|---|---|---|
|\( O(1) \)|常数阶|无循环、无递归，仅执行固定次数操作|数组访问（a[i]）、两数交换|
|\( O(log n) \)|对数阶|每次操作将问题规模缩小一半（分治思想）|二分查找、平衡二叉树查找|
|\( O(n) \)|线性阶|单重循环，操作次数与n成正比|数组遍历、线性查找|
|\( O(n log n) \)|线性对数阶|分治+线性操作，高效排序算法的核心复杂度|归并排序、快速排序（平均情况）、堆排序|
|\( O(n^2) \)|平方阶|双重嵌套循环|冒泡排序、插入排序、简单选择排序|
|\( O(n^3) \)|立方阶|三重嵌套循环|矩阵乘法（朴素算法）|
|\( O(2^n) \)|指数阶|暴力搜索、未优化的递归（问题规模每增1，操作数翻倍）|斐波那契数列递归（未优化）、子集枚举|
|\( O(n!) \)|阶乘阶|全排列、暴力回溯（效率极低，仅适用于极小n）|旅行商问题（暴力枚举所有路径）|
## 2.5 典型实例计算（考试必练）

### 实例1：常数阶 \( O(1) \)

```java

// 输入规模n不影响执行次数
int getFirst(int[] arr) {
    return arr[0]; // 仅1次操作
}
```

分析：无论数组长度n多大，仅执行1次返回操作，故 \( T(n) = 1 \) → \( O(1) \)。

### 实例2：线性阶 \( O(n) \)

```java

// 遍历数组
void traverse(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n; i++) { // 循环n次
        System.out.println(arr[i]); // 每次循环1次操作
    }
}
```

分析：循环执行n次，每次循环1次基本操作，故 \( T(n) = n \) → \( O(n) \)。若循环内有2次操作（如打印+赋值），则 \( T(n) = 2n \) → 去掉系数仍为 \( O(n) \)。

### 实例3：平方阶 \( O(n^2) \)

```java

// 冒泡排序（双重循环）
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n-1; i++) { // 外层循环n-1次
        for (int j = 0; j < n-i-1; j++) { // 内层循环最多n-1次
            if (arr[j] > arr[j+1]) { // 基本操作：比较+交换
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

分析：外层循环n-1次，内层循环次数依次为n-1、n-2、...、1，总次数为 \( (n-1)+(n-2)+...+1 = n(n-1)/2 = 0.5n² - 0.5n \)。去掉系数和低次项，得 \( O(n²) \)。

### 实例4：对数阶 \( O(log n) \)

```java

// 二分查找（有序数组）
int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

分析：每次循环将搜索范围缩小一半（right-left减半），直到范围为空。设循环次数为k，则 \( n / 2^k ≥ 1 \) → \( k ≤ log₂n \)。故循环次数为 \( log₂n \)，时间复杂度 \( O(log n) \)（对数的底数不影响复杂度，因可通过换底公式转换为常数系数，如 \( log₂n = log₁₀n / log₁₀2 \)，系数1/log₁₀2可忽略）。

### 实例5：递归算法的时间复杂度

递归算法复杂度计算核心：**递归调用次数 × 每次递归的基本操作次数**。

```java

// 归并排序（递归版）
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid); // 左半部分递归
        mergeSort(arr, mid+1, right); // 右半部分递归
        merge(arr, left, mid, right); // 合并操作，时间O(n)
    }
}
```

分析：归并排序每次将数组分成2份，递归深度为 \( log n \)（如n=8时，深度为3）；每一层递归的合并操作总次数为n（所有子数组合并的总元素数为n）。故总操作次数 \( T(n) = n log n \) → \( O(n log n) \)。

# 三、空间复杂度

## 3.1 定义

空间复杂度是指算法执行过程中**所需的额外存储空间**与输入规模 \( n \) 的函数关系，记为 \( S(n) = O(f(n)) \)。

注意：空间复杂度不包括输入数据本身占用的空间（如传入的数组、字符串），仅计算算法“额外”申请的空间（如临时变量、递归栈、新创建的数组/链表等）。

## 3.2 计算步骤

1. **确定输入规模 \( n \)**（与时间复杂度一致）。

2. **识别额外存储空间**：
        

    - 临时变量：如循环变量i、中间值temp（若数量固定，不计入n的函数）；

    - 动态申请的空间：如new创建的数组、链表（空间大小与n相关）；

    - 递归栈空间：递归调用时，系统会为每个递归栈帧分配空间（栈深度即递归次数）。

3. **统计额外空间大小 \( S(n) \)**，简化为大O记号（规则与时间复杂度一致）。

## 3.3 典型实例计算

### 实例1：常数阶 \( O(1) \)

```java

// 两数交换
void swap(int a, int b) {
    int temp = a; // 仅1个临时变量，空间固定
    a = b;
    b = temp;
}
```

分析：额外空间仅为1个临时变量temp，与n无关，故 \( S(n) = O(1) \)。

### 实例2：线性阶 \( O(n) \)

```java

// 复制数组
int[] copyArray(int[] arr) {
    int n = arr.length;
    int[] newArr = new int[n]; // 新数组占用n个空间
    for (int i = 0; i < n; i++) {
        newArr[i] = arr[i];
    }
    return newArr;
}
```

分析：额外申请了长度为n的数组newArr，故 \( S(n) = O(n) \)。

### 实例3：递归栈空间 \( O(log n) \)（归并排序）

归并排序递归调用时，每次递归将问题分成2份，递归深度为 \( log n \)（即递归栈的层数为 \( log n \)）。每个栈帧仅占用常数空间（存储left、right、mid等变量），故额外空间为 \( O(log n) \)（若不考虑合并时的临时数组，合并的临时数组空间为 \( O(n) \)，则总空间 \( O(n) \)）。

### 实例4：递归栈空间 \( O(n) \)（斐波那契递归）

```java

// 未优化的斐波那契递归
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n-1) + fib(n-2);
}
```

分析：递归调用的深度为n（如计算fib(5)，调用链为fib(5)→fib(4)→fib(3)→fib(2)，深度为4≈n），每个栈帧占用常数空间，故空间复杂度 \( S(n) = O(n) \)。

# 四、最坏情况、平均情况与最好情况

这三种情况是对算法复杂度的“场景化分析”，核心针对**时间复杂度**（空间复杂度也可分析，但考试重点在时间），描述算法在不同输入数据下的表现。

## 4.1 定义（考试高频考点）

- **最坏情况**：在所有可能的输入中，算法执行时间最长的情况，对应时间复杂度的上界 \( O(f(n)) \)。
意义：保证算法在任何输入下的执行时间都不会超过这个界限，是考试中最常考查的情况（如未特别说明，复杂度默认指最坏情况）。

- **平均情况**：在所有可能的输入中，算法执行时间的平均值（需考虑每种输入出现的概率），是更贴近实际应用的复杂度指标。

- **最好情况**：在所有可能的输入中，算法执行时间最短的情况，对应时间复杂度的下界 \( Ω(f(n)) \)（考试较少考查）。

## 4.2 计算示例（以查找算法为例）

### 场景：在长度为n的无序数组中查找目标值target（线性查找）

```java

int linearSearch(int[] arr, int target) {
    int n = arr.length;
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) return i; // 找到则返回
    }
    return -1; // 未找到
}
```

分析：

1. **最好情况**：target是数组第一个元素（i=0时找到），仅执行1次比较操作 → 时间复杂度 \( Ω(1) \)。

2. **最坏情况**：target是数组最后一个元素，或target不存在（需遍历整个数组），执行n次比较操作 → 时间复杂度 \( O(n) \)。

3. **平均情况**：假设target存在于数组中，且每个位置的概率相等（1/n）。执行次数的平均值为 \( (1 + 2 + ... + n)/n = (n+1)/2 \) → 简化为 \( O(n) \)（平均情况的复杂度与最坏情况一致）。

### 场景：在长度为n的有序数组中查找目标值target（二分查找）

分析：

1. **最好情况**：target是数组中间元素（第一次循环找到），执行1次比较 → \( Ω(1) \)。

2. **最坏情况**：target不存在，或target在数组边缘（需递归/循环到范围为空），执行 \( log n \) 次比较 → \( O(log n) \)。

3. **平均情况**：考虑所有可能的target位置，平均执行次数仍为 \( log n \) 量级 → \( O(log n) \)。

## 4.3 考试易错点

1. 若题目未说明“平均情况”或“最好情况”，则默认考查“最坏情况复杂度”；2. 快速排序的最坏情况复杂度是 \( O(n²) \)（数组已有序，每次划分仅分成1和n-1两部分），但平均情况是 \( O(n log n) \)，实际应用中因优化（如随机选基准），通常按平均情况评估；3. 平均情况的计算需考虑输入概率，若未明确概率，默认所有输入等概率出现。

# 五、考试核心考点总结与易错点

## 5.1 核心考点

1. 时间/空间复杂度的定义与大O记号的简化规则；

2. 常见复杂度等级的排序与对应算法；

3. 循环（单重、多重）、递归算法的时间复杂度计算；

4. 最坏情况与平均情况的判定及计算（以查找、排序算法为重点）；

5. 空间复杂度中递归栈空间的计算。

## 5.2 易错点

- 混淆“额外空间”与“输入空间”：空间复杂度仅计算额外申请的空间，不包括输入数据本身；

- 递归算法的空间复杂度漏算递归栈空间：递归深度即栈空间的大小；

- 对数阶复杂度的底数错误：忽略底数（如 \( log₂n \) 与 \( log₁₀n \) 均记为 \( O(log n) \)）；

- 多重循环复杂度计算错误：需区分“嵌套循环”（复杂度相乘，如双重嵌套 \( O(n²) \)）与“并列循环”（复杂度相加，取最大项，如两个单重循环 \( O(n) + O(n) = O(n) \)）。

## 5.3 经典考题预测

1. 计算下列算法的时间复杂度和空间复杂度（如冒泡排序、二分查找、归并排序的递归版）；

2. 比较不同算法的复杂度，选择最优算法（如“在n较大时，O(n log n)比O(n²)更高效”）；

3. 分析某算法的最坏情况和平均情况复杂度（如线性查找、快速排序）；

4. 判断复杂度表示的正确性（如“O(n) = O(n log n)”是否正确，答案：错误，因n的增长速度慢于n log n）。
