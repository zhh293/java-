# 数据结构中字符串核心知识点（考试专用）

## 一、字符串基本概念

### 1.1 字符串定义
字符串（String）是由零个或多个字符组成的有限序列，是数据结构中的重要组成部分。字符串中的字符可以是字母、数字、符号或空格。

### 1.2 字符串基本术语
- **空串**：长度为0的字符串，记为ε
- **子串**：串中任意连续的字符序列
- **主串**：包含子串的字符串
- **串相等**：长度相等且对应位置字符相等
- **串长度**：串中字符的个数

### 1.3 字符串的存储结构
1. **顺序存储**：使用字符数组存储
2. **链式存储**：使用链表存储（较少使用）
3. **堆分配存储**：动态分配存储空间

## 二、字符串的存储结构

### 2.1 顺序存储结构
```cpp
typedef struct String{
    char* data;    // 存储字符串的数组
    int size;      // 当前字符串长度
    int capacity;  // 数组容量
} String;
```

### 2.2 链式存储结构
```cpp
typedef struct Node{
    char data;
    struct Node* next;
} Node;
```

## 三、字符串的基本操作

### 3.1 常见操作
- **求串长**：获取字符串长度
- **串连接**：将两个字符串连接成一个
- **求子串**：从主串中提取指定位置和长度的子串
- **串比较**：比较两个字符串的大小
- **定位操作**：查找子串在主串中的位置

### 3.2 操作时间复杂度
- 求串长：O(1)（若维护长度变量）
- 串连接：O(m+n)（m、n为两串长度）
- 求子串：O(n)（n为子串长度）
- 串比较：O(min(m,n))
- 定位操作：朴素算法O(m×n)，KMP算法O(m+n)

## 四、字符串匹配算法

### 4.1 朴素匹配算法（Brute Force）
**算法思路**：从主串的第一个字符开始，与模式串逐一比较。

**时间复杂度**：
- 最好情况：O(m+n)
- 最坏情况：O(m×n)
- 平均情况：O(m+n)

### 4.2 KMP算法
**算法特点**：利用已匹配部分的信息，避免模式串指针的回溯。

**核心概念**：
- **next数组**：记录模式串中每个位置的最长公共前后缀长度
- **最长公共前后缀**：字符串的前缀与后缀的公共部分

**计算公式**：
```
next[0] = -1
next[j] = max{k | 1 ≤ k < j 且 P[0...k-1] = P[j-k...j-1]}
```

**时间复杂度**：O(m+n)

### 4.3 改进KMP算法
在KMP基础上进一步优化，当P[j] = P[next[j]]时，令nextval[j] = nextval[next[j]]。

## 五、字符串相关计算题

### 5.1 子串个数计算
**计算公式**：
- 长度为n的字符串，子串个数 = n(n+1)/2 + 1（包含空串）
- 非空子串个数 = n(n+1)/2
- 真子串个数 = n(n+1)/2 - 1（不包含自身）

**例题**：长度为5的字符串有多少个子串？
- 答案：5×(5+1)/2 + 1 = 16个（包含空串）

### 5.2 模式串next数组计算
**计算步骤**：
1. next[0] = -1（或0，根据定义而定）
2. 从左到右逐位计算
3. 对于位置j，寻找P[0...j-1]的最长公共前后缀

**例题**：模式串"ababaa"的next数组计算
```
模式串：a b a b a a
下标  ：0 1 2 3 4 5
next  ：-1 0 0 1 2 1
```

### 5.3 字符串存储地址计算
**计算公式**：LOC(ai) = LOC(a0) + i×L（L为单个字符占用空间）

**例题**：字符串"computer"按行存储，每个字符占1个字节，从地址0开始，字符'm'的地址是多少？
- 'm'在第4个位置（从0开始计数）
- 地址 = 0 + 4×1 = 4

## 六、字符串应用

### 6.1 模式匹配应用
- 文本编辑器中的查找替换功能
- 病毒检测中的特征码匹配
- 生物信息学中的DNA序列匹配

### 6.2 特殊字符串处理
- **回文串**：正读反读相同的字符串
- **最长公共子串**：两个字符串的最长公共连续子串
- **最长公共子序列**：不要求连续的最长公共序列

## 七、考试常见题型

### 7.1 选择题考点
1. 字符串基本概念理解
2. 存储结构特点对比
3. 时间复杂度判断
4. next数组计算

### 7.2 算法设计题
1. KMP算法实现
2. 字符串匹配算法设计
3. 特定模式的字符串处理

### 7.3 计算题
1. 子串个数计算
2. next数组计算
3. 存储地址计算

## 八、重要公式总结

| 计算类型 | 公式 | 说明 |
|---------|------|------|
| 子串个数 | n(n+1)/2 + 1 | 包含空串 |
| 非空子串个数 | n(n+1)/2 | 不包含空串 |
| 真子串个数 | n(n+1)/2 - 1 | 不包含自身 |
| 存储地址 | LOC(ai) = LOC(a0) + i×L | 按行存储 |
| KMP时间复杂度 | O(m+n) | m为主串长度，n为模式串长度 |

## 九、易错点与注意事项

1. **空串与空格串**：空串长度为0，空格串长度为1（或多个）
2. **子串连续性**：子串必须是连续的字符序列
3. **next数组计算**：注意起始值的设置（-1或0）
4. **字符串下标**：注意从0开始还是从1开始
5. **时间复杂度分析**：区分最好、最坏、平均情况

## 十、典型例题解析

### 例题1：next数组计算
模式串："ababaaa"
```
位置:  0 1 2 3 4 5 6
字符:  a b a b a a a
next: -1 0 0 1 2 3 1
```

### 例题2：子串个数计算
字符串"abcd"的非空子串个数为：4×(4+1)/2 = 10个
分别是：a, b, c, d, ab, bc, cd, abc, bcd, abcd

### 例题3：KMP匹配过程
主串："ababcabcacbab"，模式串："abcac"
通过KMP算法进行匹配，记录比较次数和移动过程。

字符串是数据结构中的重要内容，掌握基本概念、存储结构和匹配算法对于考试和实际应用都非常重要。