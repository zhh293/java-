# 拓扑排序算法详解

## 一、拓扑排序概述

### 1.1 基本概念

**拓扑排序（Topological Sort）**：对一个有向无环图（DAG, Directed Acyclic Graph）进行拓扑排序，是将图中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若存在边(u,v)，则在该线性序列中u出现在v之前。

**有向无环图（DAG）**：没有环的有向图，是进行拓扑排序的前提条件。

### 1.2 拓扑排序的特点

1. **方向性**：必须是有向图
2. **无环性**：图中不能存在环路
3. **序列性**：形成一个线性的顶点序列
4. **依赖性**：满足图中的依赖关系

### 1.3 拓扑排序的应用场景

- **课程安排**：安排课程的先修关系
- **项目管理**：确定任务执行顺序
- **编译顺序**：确定模块编译顺序
- **依赖解析**：解析软件包依赖关系

## 二、拓扑排序的算法原理

### 2.1 入度的概念

**入度（In-degree）**：指向某顶点的边的数目。
- 入度为0的顶点没有前驱，可以作为拓扑序列的起始点

### 2.2 拓扑排序的两种主要算法

1. **Kahn算法**：基于入度的算法
2. **基于DFS的算法**：使用深度优先搜索

## 三、Kahn算法详解

### 3.1 算法原理

Kahn算法基于这样一个事实：在DAG中，总存在入度为0的顶点。算法不断地选择入度为0的顶点，将其输出并删除，同时更新其余顶点的入度。

### 3.2 算法步骤

1. **计算入度**：计算图中每个顶点的入度
2. **初始化队列**：将所有入度为0的顶点加入队列
3. **处理顶点**：从队列中取出顶点，将其加入拓扑序列
4. **更新入度**：删除该顶点及其出边，更新其邻接顶点的入度
5. **重复过程**：如果邻接顶点入度变为0，将其加入队列
6. **检查结果**：如果拓扑序列包含所有顶点，则成功；否则图中存在环

### 3.3 算法实现

```java
import java.util.*;

public class TopologicalSortKahn {
    private int vertices;                    // 顶点数
    private List<List<Integer>> adjList;     // 邻接表
    
    public TopologicalSortKahn(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList<>();
        
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    public void addEdge(int from, int to) {
        adjList.get(from).add(to);
    }
    
    public List<Integer> topologicalSort() {
        // 1. 计算每个顶点的入度
        int[] inDegree = new int[vertices];
        for (int i = 0; i < vertices; i++) {
            for (int neighbor : adjList.get(i)) {
                inDegree[neighbor]++;
            }
        }
        
        // 2. 将所有入度为0的顶点加入队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        // 3. 存储拓扑排序结果
        List<Integer> result = new ArrayList<>();
        
        // 4. 处理队列中的顶点
        while (!queue.isEmpty()) {
            // 取出入度为0的顶点
            int current = queue.poll();
            result.add(current);
            
            // 更新其邻接顶点的入度
            for (int neighbor : adjList.get(current)) {
                inDegree[neighbor]--;
                
                // 如果邻接顶点入度变为0，加入队列
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        // 5. 检查是否存在环
        if (result.size() != vertices) {
            System.out.println("图中存在环，无法进行拓扑排序");
            return new ArrayList<>(); // 返回空列表表示排序失败
        }
        
        return result;
    }
}
```

### 3.4 Kahn算法示例

假设有一个课程先修关系图：
- 课程0：程序设计基础
- 课程1：离散数学
- 课程2：数据结构
- 课程3：高级语言程序设计
- 课程4：算法分析与设计
- 课程5：编译原理

先修关系：
- 课程0 → 课程2（程序设计基础是数据结构的先修课）
- 课程0 → 课程3（程序设计基础是高级语言程序设计的先修课）
- 课程1 → 课程2（离散数学是数据结构的先修课）
- 课程1 → 课程4（离散数学是算法分析与设计的先修课）
- 课程2 → 课程4（数据结构是算法分析与设计的先修课）
- 课程2 → 课程5（数据结构是编译原理的先修课）
- 课程3 → 课程5（高级语言程序设计是编译原理的先修课）

**算法执行过程**：

**初始状态**：
- 入度：[0, 0, 0, 0, 0, 0]（错误，需要重新计算）
- 实际入度：[0, 0, 2, 1, 2, 2]（课程0和1入度为0）

**第1步**：处理课程0
- 将课程0加入结果
- 更新课程2和3的入度：[0, 0, 1, 0, 2, 2]

**第2步**：处理课程1
- 将课程1加入结果
- 更新课程2和4的入度：[0, 0, 0, 0, 1, 2]

**第3步**：处理课程2
- 将课程2加入结果
- 更新课程4和5的入度：[0, 0, 0, 0, 0, 1]

**第4步**：处理课程3
- 将课程3加入结果
- 更新课程5的入度：[0, 0, 0, 0, 0, 0]

**第5步**：处理课程4
- 将课程4加入结果

**第6步**：处理课程5
- 将课程5加入结果

**最终结果**：[0, 1, 2, 3, 4, 5]

## 四、基于DFS的拓扑排序算法

### 4.1 算法原理

基于深度优先搜索的拓扑排序算法利用了这样一个性质：在DFS中，如果存在边(u,v)，那么v的完成时间一定早于u的完成时间。

### 4.2 算法步骤

1. **初始化**：创建访问标记数组和结果栈
2. **DFS遍历**：对每个未访问的顶点进行DFS
3. **后序处理**：在DFS的后序位置将顶点压入栈
4. **输出结果**：将栈中元素逆序输出

### 4.3 算法实现

```java
import java.util.*;

public class TopologicalSortDFS {
    private int vertices;
    private List<List<Integer>> adjList;
    
    public TopologicalSortDFS(int vertices) {
        this.vertices = vertices;
        this.adjList = new ArrayList<>();
        
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    public void addEdge(int from, int to) {
        adjList.get(from).add(to);
    }
    
    public List<Integer> topologicalSort() {
        // 0: 未访问, 1: 正在访问, 2: 已完成
        int[] visited = new int[vertices];
        Stack<Integer> stack = new Stack<>();
        
        // 对每个未访问的顶点进行DFS
        for (int i = 0; i < vertices; i++) {
            if (visited[i] == 0) {
                if (dfs(i, visited, stack)) {
                    System.out.println("图中存在环，无法进行拓扑排序");
                    return new ArrayList<>();
                }
            }
        }
        
        // 将栈中元素弹出形成拓扑序列
        List<Integer> result = new ArrayList<>();
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }
        
        return result;
    }
    
    /**
     * DFS辅助函数，检测环并进行拓扑排序
     * @param node 当前节点
     * @param visited 访问状态数组
     * @param stack 结果栈
     * @return 是否检测到环
     */
    private boolean dfs(int node, int[] visited, Stack<Integer> stack) {
        visited[node] = 1; // 标记为正在访问
        
        for (int neighbor : adjList.get(node)) {
            if (visited[neighbor] == 1) {
                // 发现后向边，存在环
                return true;
            }
            if (visited[neighbor] == 0 && dfs(neighbor, visited, stack)) {
                return true;
            }
        }
        
        visited[node] = 2; // 标记为已完成
        stack.push(node);  // 后序位置入栈
        return false;      // 未发现环
    }
}
```

## 五、拓扑排序的复杂度分析

### 5.1 时间复杂度

- **Kahn算法**：O(V + E)，其中V是顶点数，E是边数
  - 计算入度：O(V + E)
  - 处理每个顶点一次：O(V)
  - 处理每条边一次：O(E)

- **DFS算法**：O(V + E)
  - 每个顶点和每条边都只访问一次

### 5.2 空间复杂度

- **Kahn算法**：O(V)，需要额外的队列和入度数组
- **DFS算法**：O(V)，需要递归栈和访问数组

## 六、拓扑排序的实际应用

### 6.1 课程安排问题

在大学课程安排中，某些课程需要先修课程。拓扑排序可以确定一个合理的课程学习顺序。

### 6.2 项目管理

在项目管理中，任务之间存在依赖关系。拓扑排序可以确定任务的执行顺序。

### 6.3 依赖解析

在软件包管理中，包之间存在依赖关系。拓扑排序可以确定安装顺序。

## 七、拓扑排序的变种问题

### 7.1 唯一拓扑排序

如果一个DAG存在唯一的拓扑排序，则该图的拓扑排序序列是唯一的。

### 7.2 字典序最小的拓扑排序

当需要在所有可能的拓扑排序中选择字典序最小的一个时，可以在Kahn算法中使用优先队列。

```java
public List<Integer> lexicographicTopologicalSort() {
    int[] inDegree = new int[vertices];
    for (int i = 0; i < vertices; i++) {
        for (int neighbor : adjList.get(i)) {
            inDegree[neighbor]++;
        }
    }
    
    // 使用优先队列保证字典序
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for (int i = 0; i < vertices; i++) {
        if (inDegree[i] == 0) {
            pq.offer(i);
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!pq.isEmpty()) {
        int current = pq.poll();
        result.add(current);
        
        for (int neighbor : adjList.get(current)) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                pq.offer(neighbor);
            }
        }
    }
    
    if (result.size() != vertices) {
        System.out.println("图中存在环");
        return new ArrayList<>();
    }
    
    return result;
}
```

## 八、拓扑排序的常见题型

### 8.1 基础题型
- 判断给定图是否可以进行拓扑排序
- 输出拓扑排序序列
- 检测图中是否存在环

### 8.2 应用题型
- 课程安排问题
- 任务调度问题
- 依赖解析问题

### 8.3 变种题型
- 求字典序最小的拓扑排序
- 判断拓扑排序是否唯一
- 求最长路径（在DAG中）

## 九、解题技巧与注意事项

### 9.1 解题技巧

1. **正确建图**：明确节点和边的含义
2. **选择算法**：根据题目要求选择合适的算法
3. **环的检测**：拓扑排序失败意味着图中存在环
4. **结果验证**：验证拓扑序列是否满足所有边的约束

### 9.2 注意事项

1. **图的类型**：确保是DAG，否则无法拓扑排序
2. **入度计算**：正确计算每个顶点的入度
3. **边界情况**：考虑只有一个顶点或没有边的情况
4. **输出格式**：按题目要求输出拓扑序列

### 9.3 常见错误

1. **忘记检测环**：没有检查最终结果是否包含所有顶点
2. **入度计算错误**：统计入度时方向搞反
3. **算法理解错误**：混淆拓扑排序和普通的图遍历

拓扑排序是图论中的重要算法，广泛应用于有依赖关系的场景中，掌握其原理和实现对于解决实际问题具有重要意义。