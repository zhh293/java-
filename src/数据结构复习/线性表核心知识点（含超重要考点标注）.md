# 线性表核心知识点（含超重要考点标注）

# 一、线性表的定义与核心特征（超重要：基础必背）

线性表是由**n（n≥0）个具有相同数据类型**的元素组成的**有序序列**，记为 \( L = (a_1, a_2, ..., a_n) \)。

核心特征：

- 有序性：元素之间存在“一对一”的逻辑关系，即除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。

- 同构性：所有元素的数据类型相同（如全为整数、全为字符串）。

- 灵活性：n可以为0（此时称为“空表”，无任何元素），也可以动态增减元素（取决于存储结构）。

超重要考点：线性表的逻辑结构是“线性”的，但物理结构（存储结构）可分为顺序存储和链式存储，这是后续所有知识点的核心分类依据。

# 二、线性表的两种核心存储结构（超重要：考试重中之重）

线性表的存储结构决定了其操作效率，考试重点考查两种结构的对比、实现细节及复杂度分析。

## 2.1 顺序表（顺序存储结构）

### 2.1.1 定义

顺序表是用**一段地址连续的存储单元**依次存储线性表的元素，元素的逻辑顺序与物理顺序完全一致。

核心实现：通常借助数组实现，需预先分配固定大小的存储空间（静态顺序表），或动态调整存储空间（动态顺序表）。

### 2.1.2 关键属性（实现必备）

- 数据数组：存储元素的连续空间（如int[] data）。

- 表长：当前线性表中的元素个数（记为length，区别于数组容量capacity）。

- 容量：数组的最大存储容量（静态顺序表固定，动态顺序表可扩容）。

### 2.1.3 核心操作及时间复杂度（超重要：必考）

|操作|操作描述|时间复杂度|关键分析|
|---|---|---|---|
|初始化|创建空顺序表，分配存储空间|O(1)|仅需初始化数组和表长，操作次数固定|
|按位查找|查找第i个位置的元素（1≤i≤length）|O(1)|可通过数组下标直接访问（data[i-1]），随机访问特性|
|按值查找|查找值为e的元素，返回其位置|O(n)|需从表头遍历至表尾，最坏情况遍历所有元素|
|插入|在第i个位置插入元素e（1≤i≤length+1）|O(n)|需将第i~length个元素向后移动1位，最坏情况（表头插入）移动n个元素|
|删除|删除第i个位置的元素（1≤i≤length）|O(n)|需将第i+1~length个元素向前移动1位，最坏情况（表头删除）移动n-1个元素|
|求表长|返回当前元素个数length|O(1)|直接返回length属性，无需遍历|
### 2.1.4 优缺点（超重要：对比考点）

- 优点：
① 随机访问效率高（按位查找O(1)）；
② 存储密度高（无额外空间开销，仅存储元素本身）。

- 缺点：
① 插入、删除效率低（需移动大量元素）；
② 静态顺序表容量固定，易溢出；动态顺序表扩容时需拷贝元素，有时间开销；
③ 预先分配空间，可能造成浪费（容量>表长时）。

## 2.2 链表（链式存储结构）

链表是用**地址不连续的存储单元**存储线性表的元素，每个元素（称为“节点”）除存储数据外，还需存储指向直接前驱/后继的指针（或引用），通过指针维系元素的逻辑顺序。

核心分类（超重要：考试常考不同链表的差异）：单链表、双链表、循环链表。

### 2.2.1 单链表（最基础、考频最高）

#### 定义与节点结构

单链表的每个节点包含两个域：

- 数据域（data）：存储元素的值；

- 指针域（next）：存储直接后继节点的地址（或引用）。

表头节点（头节点）：可选，不存储数据，仅用于简化操作（如避免插入/删除时判断表头是否为空）；表头指针（head）：指向链表的第一个节点（若有头节点，则指向头节点）。

```java

// 单链表节点类（Java示例）
class ListNode {
    int data;       // 数据域
    ListNode next;  // 指针域，指向后继节点
    public ListNode(int data) {
        this.data = data;
        this.next = null;
    }
}
```

#### 核心操作及时间复杂度（超重要：必考）

|操作|操作描述|时间复杂度|关键分析|
|---|---|---|---|
|初始化|创建空链表（头指针指向null或头节点）|O(1)|仅需初始化头指针，操作固定|
|按位查找|查找第i个位置的节点|O(n)|需从表头开始，通过next指针依次遍历，最坏情况遍历n个节点|
|按值查找|查找值为e的节点，返回其位置|O(n)|同按位查找，需遍历对比数据域|
|插入|在第i个位置插入节点e（1≤i≤length+1）|O(n)|需先找到第i-1个节点（前驱节点），再修改指针（无需移动元素）；查找前驱节点耗时O(n)，插入操作本身O(1)|
|删除|删除第i个位置的节点|O(n)|需找到第i-1个节点，修改其next指针指向第i+1个节点；查找前驱节点耗时O(n)，删除操作本身O(1)|
|求表长|返回当前元素个数|O(n)|需从表头遍历至表尾，计数节点个数（无length属性，需动态统计）|
### 2.2.2 双链表（补充考点）

解决单链表“无法直接访问前驱节点”的问题，每个节点包含三个域：数据域（data）、前驱指针（prior，指向直接前驱节点）、后继指针（next，指向直接后继节点）。

核心优势：
① 按位查找、插入、删除时，可双向遍历，无需从头节点开始（如删除某个节点时，若已找到该节点，可直接通过prior找到前驱，无需再遍历）；
② 反向遍历（从表尾到表头）更高效。

时间复杂度：插入、删除操作在“已找到节点”的前提下，时间复杂度为O(1)（单链表需O(n)找前驱）；其他操作与单链表一致。

### 2.2.3 循环链表（补充考点）

分为循环单链表和循环双链表，核心特征是“表尾节点的指针指向表头”（循环单链表指向头节点/第一个节点，循环双链表的prior指向表尾、next指向表头）。

核心优势：
① 从任意节点可遍历整个链表（无需记录头指针）；
② 表尾插入、表头插入效率更高（循环单链表找到表尾后，可直接连接表头）。

判断空表：循环单链表头指针head的next指向自身（head.next == head）；循环双链表头节点的prior和next均指向自身。

### 2.2.4 链表的优缺点（超重要：对比考点）

- 优点：
① 插入、删除效率高（仅需修改指针，无需移动元素）；
② 动态扩容（无需预先分配空间，元素个数可任意增减，无溢出问题）；
③ 存储灵活（适应元素个数频繁变化的场景）。

- 缺点：
① 随机访问效率低（按位查找需遍历，O(n)）；
② 存储密度低（每个节点需额外存储指针域，占用更多空间）；
③ 操作复杂（需管理指针，易出现空指针、野指针错误）。

## 2.3 顺序表与链表的核心对比（超重要：考试高频选择题/简答题）

|对比维度|顺序表|链表|
|---|---|---|
|存储结构|连续存储单元|不连续存储单元，靠指针维系顺序|
|访问效率|随机访问（按位O(1)）|顺序访问（按位O(n)）|
|插入/删除效率|O(n)（需移动元素）|O(n)（找前驱）+ O(1)（改指针），整体O(n)；已找节点时O(1)|
|存储密度|高（100%，仅存元素）|低（需存指针，额外开销）|
|扩容方式|静态固定，动态需拷贝元素|动态扩容，无需拷贝|
|适用场景|频繁按位查找、元素个数稳定|频繁插入/删除、元素个数波动大|
|空间开销|可能浪费（容量>表长）|固定额外开销（指针域）|
# 三、线性表的应用与经典算法（超重要：编程题高频）

## 3.1 线性表的合并

问题：将两个有序线性表（如升序）合并为一个新的有序线性表。

核心思路（双指针法）：
① 初始化两个指针i、j，分别指向两个表的表头；
② 比较i、j指向的元素，将较小的元素插入新表，对应指针后移；
③ 当一个表遍历完毕后，将另一个表的剩余元素直接追加到新表。

时间复杂度：O(n+m)（n、m为两个表的长度）；空间复杂度：O(n+m)（存储新表）。

## 3.2 单链表的反转（超重要：编程题必考）

核心思路（迭代法）：
① 初始化三个指针：pre（前驱，初始null）、cur（当前，初始head）、next（后继，暂存cur.next）；
② 循环遍历链表：next = cur.next → cur.next = pre → pre = cur → cur = next；
③ 遍历结束后，pre即为反转后的表头。

```java

// 单链表反转（迭代法）
public ListNode reverseList(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode next = cur.next; // 暂存后继节点
        cur.next = pre; // 反转当前节点的指针
        pre = cur; // pre后移
        cur = next; // cur后移
    }
    return pre; // 反转后的表头
}
```

时间复杂度：O(n)（遍历一次链表）；空间复杂度：O(1)（仅用三个指针）。

## 3.3 查找单链表的中间节点

核心思路（快慢指针法）：
① 快指针fast和慢指针slow同时从表头出发；
② fast每次走2步，slow每次走1步；
③ 当fast走到表尾时，slow恰好走到中间节点（n为奇数时，slow指向中间；n为偶数时，slow指向中间两个节点的前一个）。

时间复杂度：O(n)；空间复杂度：O(1)。

## 3.4 检测单链表是否有环（超重要：编程题高频）

核心思路（快慢指针法）：
① 快指针fast和慢指针slow同时从表头出发；
② fast每次走2步，slow每次走1步；
③ 若链表有环，fast和slow最终会相遇；若无环，fast会先走到null。

拓展考点：找到环的入口节点（相遇后，将一个指针移回表头，两指针再每次走1步，相遇点即为环入口）。

# 四、超重要易错点与考试注意事项

1. 顺序表的下标问题：线性表的逻辑位序从1开始（如第1个元素），但数组下标从0开始，编程时需注意转换（如第i个元素对应数组下标i-1），避免下标越界。2. 单链表的头节点问题：有无头节点对插入/删除操作影响很大（无头节点时，表头插入需修改头指针；有头节点时，所有插入操作统一处理），考试时需看清题目要求。3. 链表的空指针问题：遍历链表时必须判断cur != null，否则会出现空指针异常；删除节点时，需确保前驱节点的next指向正确，避免“断链”。4. 复杂度分析误区：顺序表的插入/删除复杂度是O(n)，不是O(1)；链表的按位查找复杂度是O(n)，不是O(1)，不要混淆“操作本身”和“查找前驱的耗时”。5. 循环链表的空表判断：循环单链表空表的条件是head.next == head（有头节点），而非head == null，避免判断错误。

# 五、经典考题方向预测

1. 选择题：线性表的定义与特征、顺序表与链表的对比、复杂度判断（如“下列操作中，顺序表比链表效率高的是？”）。

2. 简答题：① 简述顺序表与链表的优缺点及适用场景；② 说明单链表、双链表、循环链表的差异。

3. 编程题：① 单链表的反转；② 有序线性表的合并；③ 单链表的环检测与环入口查找；④ 顺序表/链表的插入、删除实现。

4. 应用题：根据实际场景选择合适的线性表存储结构（如“学生成绩管理系统，需频繁查询成绩，偶尔修改，选顺序表还是链表？”）。