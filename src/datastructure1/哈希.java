package datastructure1;

public class 哈希 {
}
/*
你的理解有一定道理，但需要更精准地梳理哈希表与哈希函数的关系，以及哈希函数的实际作用场景。
首先，哈希表与哈希函数的关系：强依赖，但非唯一绑定
哈希表的核心功能是实现「键 - 值」的快速查找（平均 O (1) 复杂度），而这一功能的实现必须依赖哈希函数。具体来说：
哈希函数的作用是将输入的「键（key）」映射到哈希表的「存储索引（index）」，即通过 hash(key) → index 的过程，确定键值对在哈希表中的存储位置。没有哈希函数，哈希表就无法完成键到索引的映射，也就失去了快速查找的基础。

但反过来，哈希函数并非只为哈希表设计 —— 它是一种独立的数学工具，可以被哈希表之外的场景使用。因此，两者的关系是「哈希表依赖哈希函数实现核心功能，但哈希函数的应用不局限于哈希表」，即「强依赖但非唯一绑定」。
其次，关于哈希函数的作用：「映射」是核心，「冲突」是必然结果，而非 “防止”
需要纠正一个细节：哈希函数无法防止哈希冲突，相反，哈希冲突是哈希函数的固有特性。
哈希函数的输入空间（可能的键值范围）通常远大于哈希表的输出空间（索引范围，即哈希表长度），根据「鸽巢原理」，必然存在两个不同的键映射到同一个索引，即 hash(key1) = hash(key2)（key1 ≠ key2），这就是哈希冲突。

哈希表处理冲突的方式是通过「冲突解决策略」（如链地址法、开放寻址法等），而非哈希函数 “防止” 冲突。哈希函数的设计目标是减少冲突概率（通过让映射结果尽可能均匀分布），但无法完全避免。
最后，哈希函数的其他典型应用（不限于哈希表）
哈希函数的核心特性是「将任意大小的输入映射到固定大小的输出（哈希值）」，且具有「确定性」（相同输入必产生相同输出）和「雪崩效应」（输入微小变化导致输出大幅变化）等特性。这些特性使其在多个领域有重要作用：

密码安全领域（如密码存储）
存储用户密码时，不会直接保存明文，而是保存密码的哈希值（如用 SHA-256、bcrypt 等哈希函数）。这样即使数据库泄露，攻击者也无法直接获取明文密码。
你提到的 “防止同一个密码转化成哈希值之后相等”，更准确的说法是：通过「加盐（salt）」机制，让相同明文密码经过哈希后产生不同哈希值（如 hash(password + salt) ），避免攻击者通过彩虹表（预计算的哈希值字典）破解。这里哈希函数的作用是「单向映射」（无法从哈希值反推明文），加盐是为了增强安全性，而非哈希函数本身的功能。
数据校验（如文件完整性验证）
下载文件时，通过计算文件的哈希值（如 MD5、SHA-1），与官方提供的哈希值对比，可快速判断文件是否被篡改（微小篡改会导致哈希值完全不同，利用雪崩效应）。
分布式系统（如一致性哈希）
在分布式缓存、负载均衡中，通过哈希函数将节点或数据映射到哈希环上，实现数据的均匀分布和节点故障时的平滑迁移（如一致性哈希解决传统哈希在节点增减时的大规模数据迁移问题）。
哈希集合（HashSet）
本质是特殊的哈希表（只存键不存值），依赖哈希函数实现元素的快速插入、查找和去重。
总结
哈希表必须依赖哈希函数实现键到索引的映射，二者是「工具与依赖场景」的关系，哈希表离不开哈希函数，但哈希函数的应用不局限于哈希表。
哈希函数的核心是「映射」，而非 “防止冲突”（冲突不可避免，需通过其他策略解决）。
除哈希表外，哈希函数在密码安全、数据校验、分布式系统等领域的应用，均依赖其映射特性和单向性、雪崩效应等性质。

因此，哈希表与哈希函数并非 “强绑定”（哈希函数可独立用于其他场景），但哈希表对哈希函数是 “强依赖”（无哈希函数则无法工作）。哈希函数是更基础的数学工具，哈希表是其典型应用场景之一。








SHA-256 是 SHA-2 家族中的一种密码学哈希函数，由美国国家安全局（NSA）设计，于 2001 年发布。它能将任意长度的输入数据转换为 256 位（32 字节）的固定长度哈希值，具有高强度的抗碰撞性和雪崩效应。以下是其核心原理的详细解析：
一、总体流程
SHA-256 的计算过程分为 5 个主要步骤：

数据填充（Padding）
消息分块（Message Block）
初始化常量（Initial Hash Values）
哈希计算（Compression Function）
结果拼接（Final Hash）
二、详细步骤解析
1. 数据填充
无论输入数据长度如何，SHA-256 都会将其填充为 512 位（64 字节）的倍数。具体步骤：

附加比特：在数据末尾添加一个1，后跟若干个0，直到数据长度 ≡ 448 (mod 512)。
附加长度：在填充后的数据末尾附加原始数据长度的 64 位二进制表示。
例如，若原始数据为 511 位：
填充1后变为 512 位，但需满足 ≡ 448 (mod 512)，因此需补1 + 447 个0，共 448 位。
最后附加 64 位的原始长度（511 的二进制），总长度变为 1024 位（2 个 512 位块）。
2. 消息分块
将填充后的数据分割为 512 位（64 字节）的块，每个块进一步分为 16 个 32 位（4 字节）的字（W[0..15]）。
3. 初始化常量
SHA-256 使用 8 个固定的 32 位初始哈希值（h0~h7），这些值是前 8 个素数的平方根的小数部分二进制表示：

plaintext
h0 = 0x6a09e667
h1 = 0xbb67ae85
h2 = 0x3c6ef372
h3 = 0xa54ff53a
h4 = 0x510e527f
h5 = 0x9b05688c
h6 = 0x1f83d9ab
h7 = 0x5be0cd19
4. 哈希计算（压缩函数）
对每个 512 位消息块进行 64 轮迭代计算，每轮使用不同的常量和操作：

消息扩展：将 16 个字（W[0..15]）扩展为 64 个字（W[0..63]），使用特定的移位和异或操作生成新字。
初始化工作变量：将当前哈希值（h0~h7）复制到 8 个工作变量（a~h）。
64 轮迭代：每轮更新工作变量，使用两种逻辑函数（Σ0、Σ1）和两种辅助函数（Ch、Maj），结合轮常量（前 64 个素数的立方根小数部分）。
合并结果：将更新后的工作变量累加到原始哈希值（h0~h7）。
5. 结果拼接
所有消息块处理完毕后，将最终的 8 个哈希值（h0~h7）按顺序拼接为 256 位的哈希值。
三、核心数学运算
SHA-256 的安全性依赖于以下关键操作：

逻辑函数：
Ch(x, y, z)：选择函数，根据 x 的值选择 y 或 z。
Ch(x, y, z) = (x ∧ y) ⊻ (x̅ ∧ z)
Maj(x, y, z)：多数函数，返回多数值。
Maj(x, y, z) = (x ∧ y) ⊻ (x ∧ z) ⊻ (y ∧ z)
移位操作：
右旋转（Rotate Right，ROTR）：将二进制位循环右移。
右移位（Shift Right，SHR）：直接右移，高位补 0。
Σ 函数：
Σ0(x) 和 Σ1(x)：复杂的移位和异或组合，增强雪崩效应。
plaintext
Σ0(x) = ROTR2(x) ⊕ ROTR13(x) ⊕ ROTR22(x)
Σ1(x) = ROTR6(x) ⊕ ROTR11(x) ⊕ ROTR25(x)

四、安全性分析
SHA-256 的强度源于：

抗碰撞性：目前尚无公开的碰撞攻击（找到两个不同输入产生相同哈希值）。
雪崩效应：输入的微小变化会导致哈希值约一半的比特位翻转。
不可逆性：无法从哈希值反推原始数据。
设计复杂性：64 轮迭代和多种逻辑函数交织，增加了密码分析难度。
五、应用场景
SHA-256 广泛用于：

密码存储（如 bcrypt、scrypt）。
区块链（如比特币使用 SHA-256 生成区块哈希）。
数字签名（验证数据完整性）。
文件校验（如验证下载文件是否被篡改）。
*/
