状态机是处理「有状态对象的状态流转」的通用思想，本质是有限状态机（Finite State Machine，FSM），核心是把对象的状态、触发状态变化的事件、状态转移规则、转移时的动作做统一抽象和管理，彻底消除业务代码中大量的 if-else/switch 嵌套，让状态流转逻辑更清晰、可维护、可扩展。
状态机不是某一种具体的技术，而是一种设计思想：设计模式中的状态模式是它的面向对象实现；分布式系统中（如分布式事务、服务治理、消息队列、订单系统）是它的工程化落地（结合持久化、分布式一致性）。
下面先讲清状态机的核心概念，再通过4 个由浅入深的 Java 示例（基础硬编码→设计模式（状态模式）→枚举轻量实现→工业级框架 Spring Statemachine）讲解，覆盖「入门理解」「设计模式应用」「企业实用开发」「分布式系统进阶」全场景。
一、状态机的核心概念
有限状态机的核心是5 个关键要素，缺一不可，用通俗的话讲就是：一个对象，有固定的几个状态，遇到特定的事件，会从当前状态转移到另一个状态，转移过程中可以执行指定的动作。正式定义的 5 大核心要素：
上下文（Context）：拥有状态的核心对象（如订单、电梯、用户会话），是状态机的载体，对外提供状态操作的入口。
状态（State）：对象的有限个离散状态（如订单的「待支付」「已支付」「已取消」），状态机中状态数量是有限的（核心特征）。
事件（Event）：触发状态转移的触发条件（如订单的「支付」「取消」「发货」事件），事件是状态变化的唯一原因。
转移规则（Transition）：**「当前状态 + 触发事件 → 目标状态」** 的映射关系（如订单「待支付」+「支付事件」→「已支付」），规则是状态机的核心逻辑。
动作（Action）：状态转移过程中执行的业务逻辑（如订单从「待支付」转「已支付」时，执行「扣减库存」「生成支付记录」动作），动作可选（可无操作）。
状态机的核心优势
对比传统用if-else判断状态的写法，状态机的优势极其明显：
消除条件嵌套：把分散的状态判断集中到「转移规则」中，代码可读性提升 10 倍；
状态统一管理：所有状态、事件、转移规则都在一处定义，避免状态乱转（如订单「已完成」不能再「取消」）；
高扩展性：新增状态 / 事件 / 转移规则，只需扩展定义，无需修改原有业务代码（符合开闭原则）；
可追溯性：状态流转全程可记录（如日志、持久化），适合分布式系统的状态审计；
避免非法状态：通过转移规则严格限制状态流转，从根本上防止对象进入非法状态（如订单「已取消」不能触发「发货」）。
典型应用场景
业务系统：订单、物流、支付、工单的状态流转（最常用）；
基础组件：电梯、门禁、游戏角色的状态控制；
分布式系统：分布式事务（如 Seata 的 AT/TCC 状态）、消息队列（消息的「待发送」「已发送」「消费成功」）、服务治理（服务的「上线」「下线」「熔断」「恢复」）、缓存（「空」「加载中」「缓存成功」）。